import netius.base.errors as errors
import netius.base.legacy as legacy

from typing import Any, Callable, Generator, Optional, NoReturn, Type, Tuple

class Future:
    def __init__(self, loop: Any | None = None) -> None: ...
    def __iter__(self) -> Generator[Type[Future], Any, None]: ...
    def cleanup(self) -> None: ...
    def running(self) -> bool: ...
    def done(self) -> bool: ...
    def cancelled(self) -> bool: ...
    def finished(self) -> bool: ...
    def result(self) -> (Any | None): ...
    def exception(self, timeout: Optional[float] = ...) -> (Any | None): ...
    def partial(self, value: Any) -> None: ...
    def add_done_callback(self, function: Callable[..., Any]) -> None: ...
    def add_partial_callback(self, function: Callable[..., Any]) -> None: ...
    def add_ready_callback(self, function: Callable[..., Any]) -> None: ...
    def add_closed_callback(self, function: Callable[..., Any]) -> None: ...
    def approve(self, cleanup: bool = ...) -> None: ...
    def cancel(self, cleanup: bool = ..., force: bool = ...) -> bool: ...
    def set_result(self, result: Any, cleanup: bool = ..., force: bool = ...) -> None: ...
    def set_exception(self, exception: Any, cleanup: bool = ..., force: bool = ...) -> None: ...
    def _done_callbacks(self, cleanup: bool = ..., delayed: bool = ...) -> None: ...
    def _partial_callbacks(self, value: Any, delayed: bool = ...) -> None: ...
    def _wrap(self, future: Any) -> None: ...
    def _delay(self, callable: Callable[..., Any]) -> None: ...
    @property
    def ready(self) -> bool: ...
    @property
    def closed(self) -> bool: ...
    def _done_callbacks(self, cleanup: bool = True, delayed: bool = True) -> (Any | None): ...
    def _partial_callbacks(self, value: Any, delayed: bool = True) -> (Any | None): ...
    def _wrap(self, future: Any) -> None: ...
    def _delay(self, callable: Any) -> Any: ...

class Task(Future):
    def __init__(self, future: Any = ...) -> None: ...

class Handle:
    def __init__(self, callable_t: Any = ...) -> None: ...
    def cancel(self) -> None: ...

class Executor:
    def submit(self, callable: Callable[..., Any], *args: Any, **kwargs: Any) -> NoReturn: ...

class ThreadPoolExecutor(Executor):
    def __init__(self, owner: Any) -> None: ...
    def submit(self, callable: Callable[..., Any], *args: Any, **kwargs: Any) -> Any: ...

def coroutine(function: Callable[..., Any]) -> Callable[..., Any]: ...
def async_test_all(factory: Any = ..., close: bool = True) -> Callable[..., Any]: ...
def async_test(function: Callable[..., Any]) -> Callable[..., Any]: ...
def ensure_generator(value: Any) -> Tuple[bool, Any]: ...
def get_asyncio() -> Any: ...
def is_coroutine(callable: Callable[..., Any]) -> bool: ...
def is_coroutine_object(generator: Any) -> bool: ...
def is_coroutine_native(generator: Any) -> bool: ...
def is_future(future: Any) -> bool: ...
def is_neo() -> bool: ...
def is_asynclib() -> bool: ...
def is_await() -> bool: ...
def wakeup(force: bool = False) -> Any: ...
def sleep(timeout: Any, compat: bool = True, future: Any = ...) -> Generator[Any, Any, None]: ...
def wait(event: Any, timeout: Any | None = None, future: Any = ...) -> Generator[Any, Any, None]: ...
def notify(event: Any, data: Any | None = None) -> Any: ...
def coroutine_return(coroutine: Any) -> Generator[Any, Any, None]: ...
