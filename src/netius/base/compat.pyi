import asyncio.events
import netius.base.asynchronous as asynchronous
import netius.base.config as config
import netius.base.errors as errors
import netius.base.legacy as legacy
import netius.base.transport as transport
import socket

from typing import Any, Generator, NoReturn

class CompatLoop(asyncio.events.AbstractEventLoop):
    def __init__(self, loop: Any) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def time(self) -> float: ...
    def call_soon(self, callback: Any, *args) -> asynchronous.Handle: ...
    def call_soon_threadsafe(self, callback: Any, *args) -> asynchronous.Handle: ...
    def call_at(self, when, callback: Any, *args) -> asynchronous.Handle: ...
    def call_later(self, delay, callback: Any, *args) -> asynchronous.Handle: ...
    def create_future(self) -> asynchronous.Future: ...
    def create_task(self, coroutine: Any) -> (asynchronous.Task | Any): ...
    def create_server(self, *args, **kwargs) -> asynchronous.AwaitWrapper: ...
    def create_connection(self, *args, **kwargs) -> asynchronous.AwaitWrapper: ...
    def create_datagram_endpoint(self, *args, **kwargs) -> asynchronous.AwaitWrapper: ...
    def getaddrinfo(self, *args, **kwargs) -> asynchronous.AwaitWrapper: ...
    def getnameinfo(self, *args, **kwargs) -> asynchronous.AwaitWrapper: ...
    def run_until_complete(self, future: Any) -> Any: ...
    def run_forever(self) -> Any: ...
    def run_in_executor(self, *args, **kwargs) -> asynchronous.AwaitWrapper: ...
    def stop(self) -> None: ...
    def close(self) -> None: ...
    def get_exception_handler(self) -> Any: ...
    def set_exception_handler(self, handler: Any) -> None: ...
    def default_exception_handler(self, context: dict) -> Any: ...
    def call_exception_handler(self, context: dict) -> (Any | None): ...
    def get_debug(self) -> Any: ...
    def set_debug(self, enabled: Any) -> None: ...
    def set_default_executor(self, executor: asynchronous.Executor) -> None: ...
    def get_task_factory(self): ...
    def set_task_factory(self, factory: asynchronous.Task) -> None: ...
    def is_running(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def _getaddrinfo(
        self,
        host: Any,
        port: Any,
        family: int = ...,
        type: int = ...,
        proto: int = ...,
        flags: int = ...
    ) -> Generator[Any, Any, None]: ...
    def _getnameinfo(self, sockaddr: Any, flags: int = ...) -> NoReturn: ...
    def _run_in_executor(self, executor: asynchronous.Executor, func, *args) -> Generator[Any, Any, None] ...
    def _create_connection(
        self,
        protocol_factory: Any,
        host: Any | None = ...,
        port: Any | None = ...,
        ssl: Any | None = ...,
        family: int = ...,
        proto: int = ...,
        flags: int = ...,
        sock: Any | None = ...,
        local_addr: Any | None = ...,
        server_hostname: Any | None = ...,
        *args,
        **kwargs
    ) -> Generator[Any, Any, None]: ...
    def _create_datagram_endpoint(
        self,
        protocol_factory: Any,
        local_addr: Any | None = ...,
        remote_addr: Any | None = ...,
        family: int = ...,
        proto: int = ...,
        flags: int = ...,
        reuse_address: Any | None = ...,
        reuse_port: Any | None = ...,
        allow_broadcast: Any | None = ...,
        sock: Any | None = ...,
        *args: Any,
        **kwargs: Any
    ) -> Generator[Any, Any, None]: ...
    def _set_current_task(self, task: asynchronous.Task) -> None: ...
    def _unset_current_task(self) -> None: ...
    def _call_delay(
        self,
        callback,
        args,
        timeout: Any | None = ...,
        immediately: bool = ...,
        verify: bool = ...,
        safe: bool = ...,
    ) -> asynchronous.Handle: ...
    def _sleep(self, timeout, future: asynchronous.Future | None = ...) -> asynchronous.Future: ...
    def _default_handler(self, context: dict) -> None: ...
    @property
    def _thread_id(self) -> int: ...

def is_compat() -> bool: ...
def is_asyncio() -> bool: ...
def build_datagram(*args, **kwargs) -> (Any | None) : ...
def connect_stream(*args, **kwargs) -> (Any | None) : ...
def _build_datagram_native(
    protocol_factory: ...,
    family: socket.AddressFamily = ...,
    type: socket.SocketKind = ...,
    remote_host: Any | None = ...,
    remote_port: Any | None = ...,
    callback: Any | None = ...,
    loop: Any | None = ...,
    *args,
    **kwargs
) -> (Any | None): ...
def _build_datagram_compat(
    protocol_factory: Any,
    family: socket.AddressFamily = ...,
    type: socket.SocketKind = ...,
    remote_host: Any | None = ...,
    remote_port: Any | None = ...,
    callback: Any | None = ...,
    loop: Any | None = ...,
    *args,
    **kwargs
) -> (Any | None): ...
def _connect_stream_native(
    protocol_factory: Any,
    host: Any,
    port: Any,
    ssl: bool = ...,
    key_file: Any | None = ...,
    cer_file: Any | None = ...,
    ca_file: Any | None = ...,
    ca_root: bool = ...,
    ssl_verify: bool = ...,
    family: socket.AddressFamily = ...,
    type: socket.SocketKind = ...,
    callback: Any | None = ...,
    loop: Any | None = ...,
    *args,
    **kwargs
) -> (Any | None): ...
def _connect_stream_compat(
    protocol_factory: Any,
    host: Any,
    port: Any,
    ssl: bool = ...,
    key_file: Any | None = ...,
    cer_file: Any | None = ...,
    ca_file: Any | None = ...,
    ca_root: bool = ...,
    ssl_verify: bool = ...,
    family: socket.AddressFamily = ...,
    type: socket.SocketKind = ...,
    callback: Any | None = ...,
    loop: Any | None = ...,
    *args: Any,
    **kwargs: Any
) -> (Any | None): ...
