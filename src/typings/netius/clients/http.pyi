import netius as netius
import netius.base.agent
import netius.base.protocol
from _typeshed import Incomplete
from typing import ClassVar

__version__: str
__revision__: str
__date__: str
PLAIN_ENCODING: int
CHUNKED_ENCODING: int
GZIP_ENCODING: int
DEFLATE_ENCODING: int
Z_PARTIAL_FLUSH: int

class HTTPProtocol(netius.base.protocol.StreamProtocol):
    BASE_HEADERS: ClassVar[dict] = ...
    def __init__(self, method, url, params: Incomplete | None = ..., headers: Incomplete | None = ..., data: Incomplete | None = ..., version: str = ..., encoding: int = ..., encodings: str = ..., safe: bool = ..., request: bool = ..., asynchronous: bool = ..., timeout: Incomplete | None = ..., use_file: bool = ..., callback: Incomplete | None = ..., on_init: Incomplete | None = ..., on_open: Incomplete | None = ..., on_close: Incomplete | None = ..., on_headers: Incomplete | None = ..., on_data: Incomplete | None = ..., on_result: Incomplete | None = ..., *args, **kwargs) -> None: ...
    @classmethod
    def key_g(cls, url): ...
    @classmethod
    def decode_gzip(cls, data): ...
    @classmethod
    def decode_deflate(cls, data): ...
    @classmethod
    def decode_zlib_file(cls, input, output, buffer_size: int = ..., wbits: int = ...): ...
    @classmethod
    def decode_gzip_file(cls, input, output, buffer_size: int = ..., wbits: int = ...): ...
    @classmethod
    def decode_deflate_file(cls, input, output, buffer_size: int = ..., wbits: int = ...): ...
    @classmethod
    def set_request(cls, parser, buffer, request: Incomplete | None = ...): ...
    @classmethod
    def set_request_file(cls, parser, input, request: Incomplete | None = ..., output: Incomplete | None = ..., buffer_size: int = ...): ...
    @classmethod
    def set_error(cls, error, message: Incomplete | None = ..., request: Incomplete | None = ..., force: bool = ...): ...
    def open_c(self, *args, **kwargs): ...
    def close_c(self, *args, **kwargs): ...
    def info_dict(self, full: bool = ...): ...
    def connection_made(self, transport): ...
    def loop_set(self, loop): ...
    def flush(self, force: bool = ..., callback: Incomplete | None = ...): ...
    def send_base(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., force: bool = ..., callback: Incomplete | None = ...): ...
    def send_plain(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., force: bool = ..., callback: Incomplete | None = ...): ...
    def send_chunked(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., force: bool = ..., callback: Incomplete | None = ...): ...
    def send_gzip(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., force: bool = ..., callback: Incomplete | None = ..., level: int = ...): ...
    def set(self, method, url, params: Incomplete | None = ..., headers: Incomplete | None = ..., data: Incomplete | None = ..., version: str = ..., encoding: int = ..., encodings: str = ..., safe: bool = ..., request: bool = ..., asynchronous: bool = ..., timeout: Incomplete | None = ..., use_file: bool = ..., callback: Incomplete | None = ..., on_init: Incomplete | None = ..., on_open: Incomplete | None = ..., on_close: Incomplete | None = ..., on_headers: Incomplete | None = ..., on_data: Incomplete | None = ..., on_result: Incomplete | None = ...): ...
    def set_all(self): ...
    def set_static(self): ...
    def set_dynamic(self): ...
    def run_request(self): ...
    def send_request(self, callback: Incomplete | None = ...): ...
    def wrap_request(self, use_file: bool = ..., callback: Incomplete | None = ..., on_close: Incomplete | None = ..., on_data: Incomplete | None = ..., on_result: Incomplete | None = ...): ...
    def set_headers(self, headers, normalize: bool = ...): ...
    def normalize_headers(self): ...
    def parse(self, data): ...
    def raw_data(self, data): ...
    def is_plain(self): ...
    def is_chunked(self): ...
    def is_gzip(self): ...
    def is_deflate(self): ...
    def is_compressed(self): ...
    def is_uncompressed(self): ...
    def is_flushed(self): ...
    def is_measurable(self, strict: bool = ...): ...
    def on_data(self, data): ...
    def _on_data(self): ...
    def on_partial(self, data): ...
    def on_headers(self): ...
    def on_chunk(self, range): ...
    def _flush_plain(self, force: bool = ..., callback: Incomplete | None = ...): ...
    def _flush_chunked(self, force: bool = ..., callback: Incomplete | None = ...): ...
    def _flush_gzip(self, force: bool = ..., callback: Incomplete | None = ...): ...
    def _close_gzip(self, safe: bool = ...): ...
    def _apply_base(self, headers, replace: bool = ...): ...
    def _apply_dynamic(self, headers): ...
    def _apply_connection(self, headers, strict: bool = ...): ...
    def _headers_normalize(self, headers): ...

class HTTPClient(netius.base.agent.ClientAgent):
    class protocol(netius.base.protocol.StreamProtocol):
        BASE_HEADERS: ClassVar[dict] = ...
        def __init__(self, method, url, params: Incomplete | None = ..., headers: Incomplete | None = ..., data: Incomplete | None = ..., version: str = ..., encoding: int = ..., encodings: str = ..., safe: bool = ..., request: bool = ..., asynchronous: bool = ..., timeout: Incomplete | None = ..., use_file: bool = ..., callback: Incomplete | None = ..., on_init: Incomplete | None = ..., on_open: Incomplete | None = ..., on_close: Incomplete | None = ..., on_headers: Incomplete | None = ..., on_data: Incomplete | None = ..., on_result: Incomplete | None = ..., *args, **kwargs) -> None: ...
        @classmethod
        def key_g(cls, url): ...
        @classmethod
        def decode_gzip(cls, data): ...
        @classmethod
        def decode_deflate(cls, data): ...
        @classmethod
        def decode_zlib_file(cls, input, output, buffer_size: int = ..., wbits: int = ...): ...
        @classmethod
        def decode_gzip_file(cls, input, output, buffer_size: int = ..., wbits: int = ...): ...
        @classmethod
        def decode_deflate_file(cls, input, output, buffer_size: int = ..., wbits: int = ...): ...
        @classmethod
        def set_request(cls, parser, buffer, request: Incomplete | None = ...): ...
        @classmethod
        def set_request_file(cls, parser, input, request: Incomplete | None = ..., output: Incomplete | None = ..., buffer_size: int = ...): ...
        @classmethod
        def set_error(cls, error, message: Incomplete | None = ..., request: Incomplete | None = ..., force: bool = ...): ...
        def open_c(self, *args, **kwargs): ...
        def close_c(self, *args, **kwargs): ...
        def info_dict(self, full: bool = ...): ...
        def connection_made(self, transport): ...
        def loop_set(self, loop): ...
        def flush(self, force: bool = ..., callback: Incomplete | None = ...): ...
        def send_base(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., force: bool = ..., callback: Incomplete | None = ...): ...
        def send_plain(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., force: bool = ..., callback: Incomplete | None = ...): ...
        def send_chunked(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., force: bool = ..., callback: Incomplete | None = ...): ...
        def send_gzip(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., force: bool = ..., callback: Incomplete | None = ..., level: int = ...): ...
        def set(self, method, url, params: Incomplete | None = ..., headers: Incomplete | None = ..., data: Incomplete | None = ..., version: str = ..., encoding: int = ..., encodings: str = ..., safe: bool = ..., request: bool = ..., asynchronous: bool = ..., timeout: Incomplete | None = ..., use_file: bool = ..., callback: Incomplete | None = ..., on_init: Incomplete | None = ..., on_open: Incomplete | None = ..., on_close: Incomplete | None = ..., on_headers: Incomplete | None = ..., on_data: Incomplete | None = ..., on_result: Incomplete | None = ...): ...
        def set_all(self): ...
        def set_static(self): ...
        def set_dynamic(self): ...
        def run_request(self): ...
        def send_request(self, callback: Incomplete | None = ...): ...
        def wrap_request(self, use_file: bool = ..., callback: Incomplete | None = ..., on_close: Incomplete | None = ..., on_data: Incomplete | None = ..., on_result: Incomplete | None = ...): ...
        def set_headers(self, headers, normalize: bool = ...): ...
        def normalize_headers(self): ...
        def parse(self, data): ...
        def raw_data(self, data): ...
        def is_plain(self): ...
        def is_chunked(self): ...
        def is_gzip(self): ...
        def is_deflate(self): ...
        def is_compressed(self): ...
        def is_uncompressed(self): ...
        def is_flushed(self): ...
        def is_measurable(self, strict: bool = ...): ...
        def on_data(self, data): ...
        def _on_data(self): ...
        def on_partial(self, data): ...
        def on_headers(self): ...
        def on_chunk(self, range): ...
        def _flush_plain(self, force: bool = ..., callback: Incomplete | None = ...): ...
        def _flush_chunked(self, force: bool = ..., callback: Incomplete | None = ...): ...
        def _flush_gzip(self, force: bool = ..., callback: Incomplete | None = ...): ...
        def _close_gzip(self, safe: bool = ...): ...
        def _apply_base(self, headers, replace: bool = ...): ...
        def _apply_dynamic(self, headers): ...
        def _apply_connection(self, headers, strict: bool = ...): ...
        def _headers_normalize(self, headers): ...
    def __init__(self, auto_release: bool = ..., *args, **kwargs) -> None: ...
    @classmethod
    def get_s(cls, url, params: dict = ..., headers: dict = ..., **kwargs): ...
    @classmethod
    def post_s(cls, url, params: dict = ..., headers: dict = ..., data: Incomplete | None = ..., **kwargs): ...
    @classmethod
    def put_s(cls, url, params: dict = ..., headers: dict = ..., data: Incomplete | None = ..., **kwargs): ...
    @classmethod
    def delete_s(cls, url, params: dict = ..., headers: dict = ..., **kwargs): ...
    @classmethod
    def method_s(cls, method, url, params: dict = ..., headers: dict = ..., data: Incomplete | None = ..., version: str = ..., safe: bool = ..., asynchronous: bool = ..., daemon: bool = ..., timeout: Incomplete | None = ..., ssl_verify: bool = ..., use_file: bool = ..., callback: Incomplete | None = ..., on_init: Incomplete | None = ..., on_open: Incomplete | None = ..., on_close: Incomplete | None = ..., on_headers: Incomplete | None = ..., on_data: Incomplete | None = ..., on_result: Incomplete | None = ..., http_client: Incomplete | None = ..., **kwargs): ...
    @classmethod
    def to_response(cls, map, raise_e: bool = ...): ...
    def cleanup(self): ...
    def get(self, url, params: dict = ..., headers: dict = ..., **kwargs): ...
    def post(self, url, params: dict = ..., headers: dict = ..., data: Incomplete | None = ..., **kwargs): ...
    def put(self, url, params: dict = ..., headers: dict = ..., data: Incomplete | None = ..., **kwargs): ...
    def delete(self, url, params: dict = ..., headers: dict = ..., **kwargs): ...
    def method(self, method, url, params: Incomplete | None = ..., headers: Incomplete | None = ..., data: Incomplete | None = ..., version: str = ..., encoding: int = ..., encodings: str = ..., safe: bool = ..., request: bool = ..., close: bool = ..., asynchronous: bool = ..., timeout: Incomplete | None = ..., ssl_verify: bool = ..., use_file: bool = ..., callback: Incomplete | None = ..., on_init: Incomplete | None = ..., on_open: Incomplete | None = ..., on_close: Incomplete | None = ..., on_headers: Incomplete | None = ..., on_data: Incomplete | None = ..., on_result: Incomplete | None = ..., loop: Incomplete | None = ..., **kwargs): ...
    def _get_loop(self, **kwargs): ...
    def _close_loop(self): ...
