"""
This type stub file was generated by pyright.
"""

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
Z_PARTIAL_FLUSH = ...
class HTTPProtocol(netius.StreamProtocol):
    """
    Implementation of the HTTP protocol to be used by a client
    of the HTTP implementation to send requests and receive
    responses.
    """
    BASE_HEADERS = ...
    def __init__(self, method, url, params=..., headers=..., data=..., version=..., encoding=..., encodings=..., safe=..., request=..., asynchronous=..., timeout=..., use_file=..., callback=..., on_init=..., on_open=..., on_close=..., on_headers=..., on_data=..., on_result=..., *args, **kwargs) -> None:
        ...
    
    @classmethod
    def key_g(cls, url): # -> tuple[Any, Any | Literal[443, 80], Any]:
        ...
    
    @classmethod
    def decode_gzip(cls, data): # -> bytes:
        ...
    
    @classmethod
    def decode_deflate(cls, data): # -> bytes:
        ...
    
    @classmethod
    def decode_zlib_file(cls, input, output, buffer_size=..., wbits=...):
        ...
    
    @classmethod
    def decode_gzip_file(cls, input, output, buffer_size=..., wbits=...):
        ...
    
    @classmethod
    def decode_deflate_file(cls, input, output, buffer_size=..., wbits=...):
        ...
    
    @classmethod
    def set_request(cls, parser, buffer, request=...): # -> dict[Any, Any]:
        ...
    
    @classmethod
    def set_request_file(cls, parser, input, request=..., output=..., buffer_size=...): # -> dict[Any, Any]:
        ...
    
    @classmethod
    def set_error(cls, error, message=..., request=..., force=...): # -> dict[Any, Any] | None:
        ...
    
    def open_c(self, *args, **kwargs): # -> None:
        ...
    
    def close_c(self, *args, **kwargs): # -> None:
        ...
    
    def info_dict(self, full=...): # -> dict[Any, Any]:
        ...
    
    def connection_made(self, transport): # -> None:
        ...
    
    def loop_set(self, loop): # -> None:
        ...
    
    def flush(self, force=..., callback=...): # -> None:
        ...
    
    def send_base(self, data, stream=..., final=..., delay=..., force=..., callback=...): # -> int | None:
        ...
    
    def send_plain(self, data, stream=..., final=..., delay=..., force=..., callback=...): # -> int:
        ...
    
    def send_chunked(self, data, stream=..., final=..., delay=..., force=..., callback=...): # -> int:
        ...
    
    def send_gzip(self, data, stream=..., final=..., delay=..., force=..., callback=..., level=...): # -> int:
        ...
    
    def set(self, method, url, params=..., headers=..., data=..., version=..., encoding=..., encodings=..., safe=..., request=..., asynchronous=..., timeout=..., use_file=..., callback=..., on_init=..., on_open=..., on_close=..., on_headers=..., on_data=..., on_result=...): # -> Self:
        ...
    
    def set_all(self): # -> None:
        ...
    
    def set_static(self): # -> None:
        ...
    
    def set_dynamic(self): # -> None:
        ...
    
    def run_request(self): # -> None:
        ...
    
    def send_request(self, callback=...):
        ...
    
    def wrap_request(self, use_file=..., callback=..., on_close=..., on_data=..., on_result=...): # -> tuple[dict[str, None], Callable[..., None], Callable[..., None], Callable[..., None]]:
        """
        Wraps the current set of operations for the protocol so that
        a request object is going to be created and properly populated
        according to the multiple protocol events.

        This method should focus on wrapping the provided callback handlers
        with ones that change the request object state.

        :type use_file: bool
        :param use_file: If a filesystem based approach should be used
        for the storing of the request information.
        :type callback: Function
        :param callback: Callback function to be called when the message
        response has been completely received.
        :type on_close: Function
        :param on_close: Callback function to be called when the underlying
        protocol is closed.
        :type on_data: Function
        :param on_data: Function to be called whenever some data is received
        from the client side, notice that this data may be encoded (eg: gzip).
        :type on_result: Function
        :param on_result: Callback function to be called on the final result
        with the resulting request object.
        :rtype: Tuple
        :return: The tuple containing both the request dictionary object that
        is going to store the information for the request in the current protocol
        and the multiple changed callback methods.
        """
        ...
    
    def set_headers(self, headers, normalize=...): # -> None:
        ...
    
    def normalize_headers(self): # -> None:
        ...
    
    def parse(self, data): # -> int | Any:
        ...
    
    def raw_data(self, data): # -> bytes:
        """
        Tries to obtain the raw version of the provided data, taking
        into account the possible content encoding present for compression
        or any other kind of operation.

        :type data: String
        :param data: The data to be converted back to its original
        raw value (probably through decompression).
        :rtype: String
        :return: The final raw value for the provided data.
        """
        ...
    
    def is_plain(self): # -> bool:
        ...
    
    def is_chunked(self): # -> bool:
        ...
    
    def is_gzip(self): # -> bool:
        ...
    
    def is_deflate(self): # -> bool:
        ...
    
    def is_compressed(self): # -> bool:
        ...
    
    def is_uncompressed(self): # -> bool:
        ...
    
    def is_flushed(self): # -> bool:
        ...
    
    def is_measurable(self, strict=...): # -> bool:
        ...
    
    def on_data(self, data): # -> None:
        ...
    
    def on_partial(self, data): # -> None:
        ...
    
    def on_headers(self): # -> None:
        ...
    
    def on_chunk(self, range): # -> None:
        ...
    


class HTTPClient(netius.ClientAgent):
    """
    Simple test of an HTTP client, supports a series of basic
    operations and makes use of the HTTP parser from netius.

    The current implementation supports the auto-release of the
    connection once the message has been received, this is optional
    and may be disabled with an argument in the constructor.
    """
    protocol = HTTPProtocol
    def __init__(self, auto_release=..., *args, **kwargs) -> None:
        ...
    
    @classmethod
    def get_s(cls, url, params=..., headers=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    @classmethod
    def post_s(cls, url, params=..., headers=..., data=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    @classmethod
    def put_s(cls, url, params=..., headers=..., data=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    @classmethod
    def delete_s(cls, url, params=..., headers=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    @classmethod
    def method_s(cls, method, url, params=..., headers=..., data=..., version=..., safe=..., asynchronous=..., daemon=..., timeout=..., ssl_verify=..., use_file=..., callback=..., on_init=..., on_open=..., on_close=..., on_headers=..., on_data=..., on_result=..., http_client=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    @classmethod
    def to_response(cls, map, raise_e=...): # -> HTTPResponse:
        """
        Simple utility method that takes the classic dictionary
        based request and converts it into a simple HTTP response
        object to be used in a more interactive way.

        :type map: Dictionary
        :param map: The dictionary backed request object that is
        going to be converted into a response.
        :type raise_e: bool
        :param raise_e: If an exception should be raised in case
        there's an error in the HTTP status field.
        :rtype: HTTPResponse
        :return: The normalized response value.
        """
        ...
    
    def cleanup(self): # -> None:
        ...
    
    def get(self, url, params=..., headers=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    def post(self, url, params=..., headers=..., data=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    def put(self, url, params=..., headers=..., data=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    def delete(self, url, params=..., headers=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    
    def method(self, method, url, params=..., headers=..., data=..., version=..., encoding=..., encodings=..., safe=..., request=..., close=..., asynchronous=..., timeout=..., ssl_verify=..., use_file=..., callback=..., on_init=..., on_open=..., on_close=..., on_headers=..., on_data=..., on_result=..., loop=..., **kwargs): # -> tuple[Any | AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None, protocol | Any] | dict[str, None] | None:
        ...
    


if __name__ == "__main__":
    buffer = ...
    def on_headers(protocol, parser): # -> None:
        ...
    
    def on_partial(protocol, parser, data): # -> None:
        ...
    
    def on_message(protocol, parser, message): # -> None:
        ...
    
    def on_finish(protocol): # -> None:
        ...
    
    url = ...
    client = ...
else:
    __path__ = ...
