"""
This type stub file was generated by pyright.
"""

import contextlib
import netius
from . import parser

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
HEADER_SIZE = ...
SETTING_SIZE = ...
DATA = ...
HEADERS = ...
PRIORITY = ...
RST_STREAM = ...
SETTINGS = ...
PUSH_PROMISE = ...
PING = ...
GOAWAY = ...
WINDOW_UPDATE = ...
CONTINUATION = ...
PROTOCOL_ERROR = ...
INTERNAL_ERROR = ...
FLOW_CONTROL_ERROR = ...
SETTINGS_TIMEOUT = ...
STREAM_CLOSED = ...
FRAME_SIZE_ERROR = ...
REFUSED_STREAM = ...
CANCEL = ...
COMPRESSION_ERROR = ...
CONNECT_ERROR = ...
ENHANCE_YOUR_CALM = ...
INADEQUATE_SECURITY = ...
HTTP_1_1_REQUIRED = ...
SETTINGS_HEADER_TABLE_SIZE = ...
SETTINGS_ENABLE_PUSH = ...
SETTINGS_MAX_CONCURRENT_STREAMS = ...
SETTINGS_INITIAL_WINDOW_SIZE = ...
SETTINGS_MAX_FRAME_SIZE = ...
SETTINGS_MAX_HEADER_LIST_SIZE = ...
HTTP_20 = ...
HEADER_STATE = ...
PAYLOAD_STATE = ...
FINISH_STATE = ...
HTTP2_WINDOW = ...
HTTP2_FRAME_SIZE = ...
HTTP2_PREFACE = ...
HTTP2_PSEUDO = ...
HTTP2_TUPLES = ...
HTTP2_NAMES = ...
HTTP2_SETTINGS = ...
HTTP2_SETTINGS_OPTIMAL = ...
HTTP2_SETTINGS_T = ...
HTTP2_SETTINGS_OPTIMAL_T = ...
class HTTP2Parser(parser.Parser):
    FIELDS = ...
    def __init__(self, owner, store=..., file_limit=...) -> None:
        ...
    
    def build(self): # -> None:
        """
        Builds the initial set of states ordered according to
        their internal integer definitions, this method provides
        a fast and scalable way of parsing data.
        """
        ...
    
    def destroy(self): # -> None:
        """
        Destroys the current structure for the parser meaning that
        it's restored to the original values, this method should only
        be called on situation where no more parser usage is required.
        """
        ...
    
    def info_dict(self): # -> dict[Any, Any]:
        ...
    
    def info_streams(self): # -> list[Any]:
        ...
    
    def reset(self, store=..., file_limit=...): # -> None:
        ...
    
    def clear(self, force=..., save=...): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def parse(self, data): # -> int | Any:
        """
        Parses the provided data chunk, changing the current
        state of the parser accordingly and returning the
        number of processed bytes from it.

        :type data: String
        :param data: The string containing the data to be parsed
        in the current parse operation.
        :rtype: int
        :return: The amount of bytes of the data string that have
        been "parsed" in the current parse operation.
        """
        ...
    
    def get_type_s(self, type): # -> str | None:
        """
        Retrieves the string based representation of the frame
        type according to the HTTP2 specification.

        :type type: int
        :param type: The frame type as an integer that is going
        to be converted to the string representation.
        :rtype: String
        :return: The string based representation of the frame type.
        """
        ...
    
    def assert_header(self): # -> None:
        """
        Runs a series of assertion operations related with the
        header of the frame, making sure it remains compliant
        with the HTTP 2 specification.
        """
        ...
    
    def assert_stream(self, stream): # -> None:
        ...
    
    def assert_data(self, stream, end_stream): # -> None:
        ...
    
    def assert_headers(self, stream, end_stream): # -> None:
        ...
    
    def assert_priority(self, stream, dependency): # -> None:
        ...
    
    def assert_rst_stream(self, stream): # -> None:
        ...
    
    def assert_settings(self, settings, ack, extended=...): # -> None:
        ...
    
    def assert_push_promise(self, promised_stream):
        ...
    
    def assert_ping(self): # -> None:
        ...
    
    def assert_goaway(self): # -> None:
        ...
    
    def assert_window_update(self, stream, increment): # -> None:
        ...
    
    def assert_continuation(self, stream): # -> None:
        ...
    
    @property
    def type_s(self): # -> str | None:
        ...
    
    @property
    def buffer_size(self): # -> int:
        ...
    
    @property
    def buffer_data(self, empty=...): # -> bytes:
        ...
    
    @property
    def encoder(self):
        ...
    
    @property
    def decoder(self):
        ...
    


class HTTP2Stream(netius.Stream):
    """
    Object representing a stream of data interchanged between two
    peers under the HTTP 2 protocol.

    A stream may be considered a node in a tree of dependencies,
    the children references are stored on the parent node.

    Should be compatible with both the parser and the connection
    interfaces and may be used for both types of operations.

    :see: https://tools.ietf.org/html/rfc7540
    """
    def __init__(self, identifier=..., header_b=..., dependency=..., weight=..., exclusive=..., end_headers=..., end_stream=..., end_stream_l=..., store=..., file_limit=..., window=..., frame_size=..., *args, **kwargs) -> None:
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    def reset(self, store=..., file_limit=..., window=..., frame_size=...): # -> None:
        ...
    
    def open(self): # -> None:
        ...
    
    def close(self, flush=..., destroy=..., reset=...): # -> None:
        ...
    
    def info_dict(self, full=...): # -> dict[str, int]:
        ...
    
    def available(self): # -> None:
        """
        Method called upon the become available event triggered
        when a blocked stream becomes "unblocked" again, this is a
        level operation that is only called once.
        """
        ...
    
    def unavailable(self): # -> None:
        """
        Called whenever an "unblocked" stream becomes "blocked" again
        this is called only upon the "edge" (once). After this event
        the stream should no longer send frames containing data.
        """
        ...
    
    def set_encoding(self, encoding): # -> None:
        ...
    
    def set_uncompressed(self): # -> None:
        ...
    
    def set_plain(self): # -> None:
        ...
    
    def set_chunked(self): # -> None:
        ...
    
    def set_gzip(self): # -> None:
        ...
    
    def set_deflate(self): # -> None:
        ...
    
    def is_plain(self): # -> bool:
        ...
    
    def is_chunked(self): # -> bool:
        ...
    
    def is_gzip(self): # -> bool:
        ...
    
    def is_deflate(self): # -> bool:
        ...
    
    def is_compressed(self): # -> bool:
        ...
    
    def is_uncompressed(self): # -> bool:
        ...
    
    def is_flushed(self): # -> bool:
        ...
    
    def is_measurable(self, strict=...): # -> bool:
        ...
    
    def is_exhausted(self): # -> bool:
        ...
    
    def is_restored(self): # -> bool:
        ...
    
    def decode_headers(self, force=..., assert_h=...): # -> None:
        ...
    
    def extend_headers(self, fragment): # -> None:
        """
        Extends the headers data buffer with the provided
        data fragment. This method may be used for adding
        headers data coming from a continuation frame.

        :type fragment: String
        :param fragment: The data fragment to be used in
        the extension of the headers data.
        """
        ...
    
    def extend_data(self, data): # -> None:
        """
        Adds a data chunk to the buffer associated with the
        stream. Note that the buffer is only populated in case
        the store flag is currently set.

        Even if the store flag is not set this method should be
        called whenever a new data chunk is received in the stream.

        :type data: String
        :param data: The data chunk to be added to the stream's
        internal buffers.
        """
        ...
    
    def remote_update(self, increment): # -> None:
        """
        Updates the remote window value, the remote windows is
        the window that controls the output stream of bytes and
        should represent the number of available bytes in the
        remote peer that can be immediately processed.

        :type increment: int
        :param increment: The increment in bytes to be added to
        the current remote window value, this value may be negative.
        """
        ...
    
    def local_update(self, increment): # -> None:
        """
        Increments the current local window value with the increment
        (in bytes) passed as parameter.

        The local window represents the number of bytes that can be
        processed in the current local buffer, effectively representing
        the number of bytes that may still be received in the stream.

        In case the window threshold is reached the method triggers
        the sending of the window update frame.

        :type increment: int
        :param increment: The number of bytes that are going to be
        incremented in the local window value.
        """
        ...
    
    def get_path(self, normalize=...): # -> str:
        """
        Retrieves the path associated with the request, this
        value should be interpreted from the HTTP status line.

        In case the normalize flag is set a possible absolute
        URL value should be normalized into an absolute path.
        This may be required under some proxy related scenarios.

        :type normalize: bool
        :param normalize: If the normalization process should be
        applied for absolute URL scenarios.
        :rtype: String
        :return: The path associated with the current request.
        """
        ...
    
    def get_query(self): # -> str:
        """
        Retrieves the (GET) query part of the path, this is considered
        to be the part of the path after the first question mark.

        This query string may be used to parse any possible (GET)
        arguments.

        :rtype: String
        :return: The query part of the path, to be used for parsing
        of (GET) arguments.
        """
        ...
    
    def get_message_b(self, copy=..., size=...): # -> _TemporaryFileWrapper[bytes] | BytesIO | StringIO | None:
        """
        Retrieves a new buffer associated with the currently
        loaded message.

        In case the current parsing operation is using a file like
        object for the handling this object it is returned instead.

        The call of this method is only considered to be safe after
        the complete message has been received and processed, otherwise
        and invalid message file structure may be created.

        Note that the returned object will always be set at the
        beginning of the file, so some care should be taken in usage.

        :type copy: bool
        :param copy: If a copy of the file object should be returned
        or if instead the shallow copy associated with the parser should
        be returned instead, this should be used carefully to avoid any
        memory leak from file descriptors.
        :type size: int
        :param size: Size (in bytes) of the buffer to be used in a possible
        copy operation between buffers.
        :rtype: File
        :return: The file like object that may be used to percolate
        over the various parts of the current message contents.
        """
        ...
    
    def get_encodings(self): # -> list[Any]:
        ...
    
    def fragment(self, data): # -> Generator[Any, Any, None]:
        ...
    
    def fragmentable(self, data): # -> bool:
        ...
    
    def flush(self, *args, **kwargs): # -> Literal[0]:
        ...
    
    def flush_s(self, *args, **kwargs): # -> Literal[0]:
        ...
    
    def send_response(self, *args, **kwargs): # -> Literal[0]:
        ...
    
    def send_header(self, *args, **kwargs): # -> Literal[0]:
        ...
    
    def send_part(self, *args, **kwargs): # -> Literal[0]:
        ...
    
    def send_reset(self, *args, **kwargs): # -> Literal[0]:
        ...
    
    def assert_headers(self): # -> None:
        ...
    
    def assert_ready(self): # -> None:
        ...
    
    @contextlib.contextmanager
    def ctx_request(self, args=..., kwargs=...): # -> Generator[None, Any, None]:
        ...
    
    @property
    def parser(self): # -> Self:
        ...
    
    @property
    def is_ready(self, calculate=..., assert_r=...): # -> bool:
        """
        Determines if the stream is ready, meaning that the complete
        set of headers and data have been passed to peer and the request
        is ready to be passed to underlying layers for processing.

        :type calculate: bool
        :param calculate: If the calculus of the content length should be
        taken into consideration meaning that the content/data length should
        be ensured to be calculated.
        :type assert_r: bool
        :param assert_r: If the extra assert (ready) operation should be
        performed to ensure that proper data values are defined in the request.
        :rtype: bool
        :return: The final value on the is ready (for processing).
        """
        ...
    
    @property
    def is_headers(self): # -> bool:
        ...
    


