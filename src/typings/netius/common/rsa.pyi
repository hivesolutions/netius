"""
This type stub file was generated by pyright.
"""

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
PRIVATE_TOKEN = ...
PUBLIC_TOKEN = ...
def open_pem_key(path, token=...): # -> bytes:
    ...

def open_pem_data(data, token=...): # -> bytes:
    ...

def write_pem_key(path, data, token=..., width=...): # -> None:
    ...

def open_private_key(path): # -> dict[str, int]:
    ...

def open_private_key_b64(data_b64): # -> dict[str, int]:
    ...

def open_private_key_data(data): # -> dict[str, int]:
    ...

def open_public_key(path): # -> dict[str, int]:
    ...

def open_public_key_b64(data_b64): # -> dict[str, int]:
    ...

def open_public_key_data(data): # -> dict[str, int]:
    ...

def write_private_key(path, private_key): # -> None:
    ...

def write_public_key(path, public_key): # -> None:
    ...

def asn_private_key(private_key): # -> bytes:
    ...

def asn_public_key(public_key): # -> bytes:
    ...

def pem_to_der(in_path, out_path, token=...): # -> None:
    ...

def pem_limiters(token): # -> tuple[Any | _bytes, Any | _bytes]:
    ...

def private_to_public(private_key): # -> dict[str, Any]:
    ...

def assert_private(private_key, number_bits=...): # -> None:
    ...

def rsa_private(number_bits): # -> dict[str, int]:
    """
    Generates a new "random" private with the requested number
    of bits as the base for exponents and modulus.

    This method is extremely time consuming in terms of processor
    and should be used carefully to avoid any problem.

    :type number_bits: int
    :param number_bits: The number of bits that are going to be
    used for the generation of the private key.
    :rtype: Dictionary
    :return: The generated private key structure, may then be used
    for processing or written to a file.
    """
    ...

def rsa_primes(number_bits): # -> tuple[Any, Any]:
    """
    Generates two different prime numbers (p and q values)
    and returns them inside a tuple structure.

    The generation is made according to the number of bits
    defined and using a trial and error strategy (expensive).

    :type number_bits: int
    :param number_bits: The number of bits to be used in
    prime generation, this affects security.
    :rtype: Tuple
    :return: A tuple containing the two different prime
    numbers to be returned.
    """
    ...

def rsa_exponents(prime_1, prime_2, number_bits, basic=...): # -> tuple[Any | Literal[65537], Any | Literal[1]]:
    """
    Generates both the public and the private exponents for
    the RSA cryptography system taking as base the provided
    prime numbers and the amount of bits for the values.

    :type prime_1: int
    :param prime_1: The first prime number use for RSA.
    :type prime_2: int
    :param prime_2: The second prime number use for RSA.
    :type number_bits: int
    :param number_bits: The number of bits that are going to be
    used for the generation of the values.
    :type basic: bool
    :param basic: If the basic approach to the generation of the
    public exponent should be taken into account.
    :rtype: Tuple
    :return: The tuple containing the generated public and
    private keys (properly tested).
    """
    ...

def rsa_bits(modulus): # -> int:
    ...

def rsa_sign(message, private_key): # -> LiteralString | bytes:
    ...

def rsa_verify(signature, public_key): # -> LiteralString | bytes:
    ...

def rsa_crypt_s(message, exponent, modulus): # -> LiteralString | bytes:
    ...

def rsa_crypt(number, exponent, modulus):
    ...

