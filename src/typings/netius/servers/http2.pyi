import netius as netius
import netius.servers.http
import netius.servers.http as http
from _typeshed import Incomplete

__version__: str
__revision__: str
__date__: str

class HTTP2Connection(netius.servers.http.HTTPConnection):
    def __init__(self, legacy: bool = ..., window: int = ..., settings: dict = ..., settings_r: dict = ..., *args, **kwargs) -> None: ...
    def open(self, *args, **kwargs): ...
    def info_dict(self, full: bool = ...): ...
    def flush_s(self, stream: Incomplete | None = ..., callback: Incomplete | None = ...): ...
    def set_h2(self): ...
    def parse(self, data): ...
    def parse_preface(self, data): ...
    def send_plain(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_chunked(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_fragmented(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_response(self, data: Incomplete | None = ..., headers: Incomplete | None = ..., version: Incomplete | None = ..., code: int = ..., code_s: Incomplete | None = ..., apply: bool = ..., stream: Incomplete | None = ..., final: bool = ..., flush: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_header(self, headers: Incomplete | None = ..., version: Incomplete | None = ..., code: int = ..., code_s: Incomplete | None = ..., stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_part(self, data, stream: Incomplete | None = ..., final: bool = ..., flush: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_frame(self, type: int = ..., flags: int = ..., payload: bytes = ..., stream: int = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_data(self, data: bytes = ..., end_stream: bool = ..., stream: Incomplete | None = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_headers(self, headers: list = ..., end_stream: bool = ..., end_headers: bool = ..., stream: Incomplete | None = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_rst_stream(self, error_code: int = ..., stream: Incomplete | None = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_settings(self, settings: tuple = ..., ack: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_ping(self, opaque: bytes = ..., ack: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_goaway(self, last_stream: int = ..., error_code: int = ..., message: str = ..., close: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_window_update(self, increment: int = ..., stream: Incomplete | None = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_delta(self): ...
    def delay_frame(self, *args, **kwargs): ...
    def flush_frames(self, all: bool = ...): ...
    def flush_available(self): ...
    def set_settings(self, settings): ...
    def close_stream(self, stream, final: bool = ..., flush: bool = ..., reset: bool = ...): ...
    def available_stream(self, stream, length, strict: bool = ...): ...
    def fragment_stream(self, stream, data): ...
    def fragmentable_stream(self, stream, data): ...
    def open_stream(self, stream): ...
    def try_available(self, stream, strict: bool = ...): ...
    def try_unavailable(self, stream, strict: bool = ...): ...
    def increment_remote(self, stream, increment, all: bool = ...): ...
    def increment_local(self, stream, increment): ...
    def error_connection(self, last_stream: int = ..., error_code: int = ..., message: str = ..., close: bool = ..., callback: Incomplete | None = ...): ...
    def error_stream(self, stream, last_stream: int = ..., error_code: int = ..., message: str = ..., close: bool = ..., callback: Incomplete | None = ...): ...
    def on_header(self, header): ...
    def on_payload(self): ...
    def on_frame(self): ...
    def on_data_h2(self, stream, contents): ...
    def on_headers_h2(self, stream): ...
    def on_rst_stream(self, stream, error_code): ...
    def on_settings(self, settings, ack): ...
    def on_ping(self, opaque, ack): ...
    def on_goaway(self, last_stream, error_code, extra): ...
    def on_window_update(self, stream, increment): ...
    def on_continuation(self, stream): ...
    def is_throttleable(self): ...
    def _build_c(self, callback, stream, data_l): ...
    def _flush_plain(self, stream: Incomplete | None = ..., callback: Incomplete | None = ...): ...
    def _flush_chunked(self, stream: Incomplete | None = ..., callback: Incomplete | None = ...): ...
    @property
    def connection_ctx(self): ...
    @property
    def parser_ctx(self): ...

class HTTP2Server(netius.servers.http.HTTPServer):
    def __init__(self, legacy: bool = ..., safe: bool = ..., settings: dict = ..., *args, **kwargs) -> None: ...
    @classmethod
    def _has_hpack(cls): ...
    @classmethod
    def _has_alpn(cls): ...
    @classmethod
    def _has_npn(cls): ...
    def info_dict(self, full: bool = ...): ...
    def get_protocols(self): ...
    def build_connection(self, socket, address, ssl: bool = ...): ...
    def on_exception(self, exception, connection): ...
    def on_ssl(self, connection): ...
    def on_serve(self): ...
    def on_preface_http2(self, connection, parser): ...
    def on_header_http2(self, connection, parser, header): ...
    def on_payload_http2(self, connection, parser): ...
    def on_frame_http2(self, connection, parser): ...
    def on_data_http2(self, connection, parser, stream, contents): ...
    def on_headers_http2(self, connection, parser, stream): ...
    def on_rst_stream_http2(self, connection, parser, stream, error_code): ...
    def on_settings_http2(self, connection, parser, settings, ack): ...
    def on_ping_http2(self, connection, parser, opaque, ack): ...
    def on_goaway_http2(self, connection, parser, last_stream, error_code, extra): ...
    def on_window_update_http2(self, connection, parser, stream, increment): ...
    def on_continuation_http2(self, connection, parser, stream): ...
    def on_send_http2(self, connection, parser, type, flags, payload, stream): ...
    def _has_h2(self): ...
    def _has_all_h2(self): ...
    def _handle_exception(self, exception, connection): ...
    def _log_frame(self, connection, parser): ...
    def _log_error(self, error_code, extra): ...
    def _log_send(self, connection, parser, type, flags, payload, stream): ...
    def _log_window(self, parser, stream, remote: bool = ...): ...
    def _log_frame_details(self, parser, type_s, flags, payload, stream, out): ...
    def _log_frame_flags(self, type_s, *args): ...
    def _log_frame_data(self, parser, flags, payload, stream, out): ...
    def _log_frame_headers(self, parser, flags, payload, stream, out): ...
    def _log_frame_rst_stream(self, parser, flags, payload, stream, out): ...
    def _log_frame_goaway(self, parser, flags, payload, stream, out): ...
    def _log_frame_window_update(self, parser, flags, payload, stream, out): ...
    def _flags_l(self, flags, definition): ...
