import netius as netius
import netius.base.conn
import netius.base.server
from _typeshed import Incomplete
from typing import ClassVar

__version__: str
__revision__: str
__date__: str
PLAIN_ENCODING: int
CHUNKED_ENCODING: int
GZIP_ENCODING: int
DEFLATE_ENCODING: int
Z_PARTIAL_FLUSH: int
ENCODING_MAP: dict

class HTTPConnection(netius.base.conn.BaseConnection):
    def __init__(self, encoding: int = ..., *args, **kwargs) -> None: ...
    def open(self, *args, **kwargs): ...
    def close(self, *args, **kwargs): ...
    def info_dict(self, full: bool = ...): ...
    def flush(self, stream: Incomplete | None = ..., callback: Incomplete | None = ...): ...
    def flush_s(self, stream: Incomplete | None = ..., callback: Incomplete | None = ...): ...
    def send_base(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_plain(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_chunked(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_gzip(self, data, stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ..., level: int = ...): ...
    def send_response(self, data: Incomplete | None = ..., headers: Incomplete | None = ..., version: Incomplete | None = ..., code: int = ..., code_s: Incomplete | None = ..., apply: bool = ..., stream: Incomplete | None = ..., final: bool = ..., flush: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_header(self, headers: Incomplete | None = ..., version: Incomplete | None = ..., code: int = ..., code_s: Incomplete | None = ..., stream: Incomplete | None = ..., final: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def send_part(self, data, stream: Incomplete | None = ..., final: bool = ..., flush: bool = ..., delay: bool = ..., callback: Incomplete | None = ...): ...
    def parse(self, data): ...
    def resolve_encoding(self, parser): ...
    def set_encoding(self, encoding): ...
    def set_uncompressed(self): ...
    def set_plain(self): ...
    def set_chunked(self): ...
    def set_gzip(self): ...
    def set_deflate(self): ...
    def is_plain(self): ...
    def is_chunked(self): ...
    def is_gzip(self): ...
    def is_deflate(self): ...
    def is_compressed(self): ...
    def is_uncompressed(self): ...
    def is_flushed(self): ...
    def is_measurable(self, strict: bool = ...): ...
    def on_data(self): ...
    def ctx_request(self, *args, **kwds): ...
    def _flush_plain(self, stream: Incomplete | None = ..., callback: Incomplete | None = ...): ...
    def _flush_chunked(self, stream: Incomplete | None = ..., callback: Incomplete | None = ...): ...
    def _flush_gzip(self, stream: Incomplete | None = ..., callback: Incomplete | None = ...): ...
    def _get_gzip(self, stream, level: int = ..., ensure: bool = ...): ...
    def _set_gzip(self, stream, gzip): ...
    def _unset_gzip(self, stream): ...
    def _close_gzip(self, safe: bool = ...): ...
    @property
    def connection_ctx(self): ...
    @property
    def parser_ctx(self): ...

class HTTPServer(netius.base.server.StreamServer):
    BASE_HEADERS: ClassVar[dict] = ...
    def __init__(self, encoding: str = ..., common_log: Incomplete | None = ..., *args, **kwargs) -> None: ...
    @classmethod
    def build_data(cls, text, url: Incomplete | None = ..., trace: bool = ..., style: bool = ..., style_urls: list = ..., encode: bool = ..., encoding: str = ...): ...
    @classmethod
    def build_text(cls, text, trace: bool = ..., style: bool = ..., style_urls: list = ..., encode: bool = ..., encoding: str = ...): ...
    @classmethod
    def build_iframe(cls, text, url, style: bool = ..., style_urls: list = ..., encode: bool = ..., encoding: str = ...): ...
    @classmethod
    def _gen_text(cls, text, trace: bool = ..., style: bool = ..., style_urls: list = ...): ...
    @classmethod
    def _gen_iframe(cls, text, url, style: bool = ..., style_urls: list = ...): ...
    @classmethod
    def _gen_header(cls, title, meta: bool = ..., style: bool = ..., style_urls: list = ...): ...
    @classmethod
    def _gen_footer(cls): ...
    @classmethod
    def _gen_style(cls): ...
    def cleanup(self): ...
    def info_dict(self, full: bool = ...): ...
    def on_data(self, connection, data): ...
    def on_serve(self): ...
    def build_connection(self, socket, address, ssl: bool = ...): ...
    def on_data_http(self, connection, parser): ...
    def on_send_http(self, connection, parser, headers: Incomplete | None = ..., version: Incomplete | None = ..., code: int = ..., code_s: Incomplete | None = ...): ...
    def on_flush_http(self, connection, parser, encoding: Incomplete | None = ...): ...
    def authorize(self, connection, parser, auth: Incomplete | None = ..., **kwargs): ...
    def _apply_all(self, parser, connection, headers, upper: bool = ..., normalize: bool = ..., replace: bool = ...): ...
    def _apply_base(self, headers, replace: bool = ...): ...
    def _apply_parser(self, parser, headers, replace: bool = ...): ...
    def _apply_connection(self, connection, headers, strict: bool = ...): ...
    def _headers_upper(self, headers): ...
    def _headers_normalize(self, headers): ...
    def _authorization(self, parser): ...
    def _write_common(self, message, encoding: str = ...): ...
    def _log_request(self, connection, parser, *args, **kwargs): ...
    def _log_request_basic(self, connection, parser, output: Incomplete | None = ...): ...
    def _log_request_common(self, connection, parser, headers: Incomplete | None = ..., version: Incomplete | None = ..., code: int = ..., code_s: Incomplete | None = ..., size_s: Incomplete | None = ..., username: str = ..., output: Incomplete | None = ...): ...
