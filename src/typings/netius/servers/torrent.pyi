"""
This type stub file was generated by pyright.
"""

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
REFRESH_TIME = ...
ID_STRING = ...
BLOCK_SIZE = ...
THRESHOLD_END = ...
MAX_MISSING = ...
PEER_PATHS = ...
class Pieces(netius.Observable):
    """
    Class that represents the logical structure of a file that is
    divided into pieces and blocks as a hierarchy, this class is
    responsible for the management of the data structures of such
    data storage model.

    A piece is considered to be the basic unit of a torrent file
    and each piece is composed by multiple blocks, note that the
    number of blocks is fixed for all the pieces of a file.
    """
    def __init__(self, length, number_pieces, number_blocks) -> None:
        ...
    
    def piece(self, index):
        ...
    
    def piece_blocks(self, index): # -> Any | int:
        ...
    
    def piece_size(self, index):
        ...
    
    def block(self, index, begin):
        ...
    
    def block_size(self, index, begin): # -> Literal[16384]:
        ...
    
    def pop_block(self, bitfield, mark=...): # -> tuple[int, int | Any, Any | Literal[16384]] | None:
        ...
    
    def push_block(self, index, begin): # -> None:
        ...
    
    def mark_piece(self, index, value=...): # -> None:
        ...
    
    def mark_block(self, index, begin, value=...): # -> None:
        ...
    
    def update_block(self, index, mark=...): # -> int:
        ...
    
    def update_piece(self, index): # -> None:
        ...
    
    @property
    def total_pieces(self): # -> Any:
        ...
    
    @property
    def marked_pieces(self): # -> int:
        ...
    
    @property
    def missing_pieces(self, max_missing=...): # -> list[Any]:
        ...
    
    @property
    def total_blocks(self):
        ...
    
    @property
    def marked_blocks(self): # -> int:
        ...
    
    @property
    def missing_blocks(self, max_missing=...): # -> list[Any]:
        ...
    


class TorrentTask(netius.Observable):
    """
    Describes a task (operation) that is going to be performed
    using the peer to peer mesh network of the torrent protocol.

    Each of the download operations should be able to be described
    by this task object (for latter reference).

    This should be considered the main interface to interact from
    a developer point of view, as such the methods should represent
    a proper easily described interface.
    """
    def __init__(self, owner, target_path, torrent_path=..., info_hash=...) -> None:
        ...
    
    def load(self): # -> None:
        ...
    
    def unload(self): # -> None:
        ...
    
    def on_close(self, connection): # -> None:
        ...
    
    def ticks(self): # -> None:
        ...
    
    def refresh(self): # -> None:
        ...
    
    def on_choked(self, connection): # -> None:
        ...
    
    def on_unchoked(self, connection): # -> None:
        ...
    
    def on_block(self, pieces, index, begin): # -> None:
        ...
    
    def on_piece(self, pieces, index): # -> None:
        ...
    
    def on_complete(self, pieces): # -> None:
        ...
    
    def on_dht(self, response): # -> None:
        ...
    
    def on_tracker(self, client, parser, result): # -> None:
        ...
    
    def load_info(self, torrent_path): # -> dict[Any, Any] | list[Any] | int | LiteralString:
        ...
    
    def load_file(self): # -> None:
        ...
    
    def load_single(self): # -> None:
        ...
    
    def load_multiple(self): # -> None:
        ...
    
    def unload_file(self): # -> None:
        ...
    
    def load_pieces(self): # -> None:
        ...
    
    def unload_pieces(self): # -> None:
        ...
    
    def pieces_tracker(self): # -> None:
        ...
    
    def set_data(self, data, index, begin): # -> None:
        ...
    
    def write_data(self, data, offset): # -> None:
        ...
    
    def set_dht(self, peer_t, port): # -> None:
        ...
    
    def peers_dht(self): # -> None:
        ...
    
    def peers_tracker(self): # -> None:
        """
        Tries to retrieve as much information as possible about the
        peers from the currently loaded tracker information.

        It's possible that no tracker information exits for the current
        task and for such situations no state change will occur.
        """
        ...
    
    def peers_file(self): # -> None:
        ...
    
    def connect_peers(self): # -> None:
        ...
    
    def disconnect_peers(self): # -> None:
        ...
    
    def connect_peer(self, peer): # -> None:
        ...
    
    def info_string(self):
        ...
    
    def left(self):
        ...
    
    def speed(self): # -> float:
        """
        Retrieves a float number representing the global speed
        of the task in bytes per second, this value is computed
        using the original creation time of the task and so it
        may not represent the most accurate speedup.

        :rtype: float
        :return: The current speed of download, defined as bytes
        per second from the original task creation time.
        """
        ...
    
    def speed_s(self):
        ...
    
    def percent(self): # -> float:
        ...
    
    def pop_block(self, bitfield): # -> tuple[int, int | Any, Any | Literal[16384]] | None:
        ...
    
    def push_block(self, index, begin): # -> None:
        ...
    
    def verify_piece(self, index): # -> None:
        ...
    
    def confirm_piece(self, index): # -> None:
        ...
    
    def refute_piece(self, index): # -> None:
        ...
    
    def extend_peers(self, peers): # -> None:
        ...
    
    def add_peer(self, peer): # -> None:
        ...
    
    def remove_peer(self, peer): # -> None:
        ...
    


class TorrentServer(netius.ContainerServer):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def cleanup(self): # -> None:
        ...
    
    def ticks(self): # -> None:
        ...
    
    def download(self, target_path, torrent_path=..., info_hash=..., close=...): # -> TorrentTask:
        """
        Starts the "downloading" process of a torrent associated file
        using the defined peer to peer torrent strategy using either
        the provided torrent path as reference or just the info hash
        of the file that is going to be downloaded.

        Note that if only the info hash is provided a DHT based strategy
        is going to be used to retrieve the peers list.

        The returned value is the task entity representing the newly created
        task for the downloading of the requested file, this object may be
        used for the operations and listening of events.

        :type target_path: String
        :param target_path: The path to the directory that will be used to store
        the binary information resulting from the download, this directory may also
        be used to store some temporary information on state of download.
        :type torrent_path: String
        :param torrent_path: The path to the file that contains the torrent
        information that is going to be used for file processing.
        :type info_hash: String
        :param info_hash: The info hash value of the file that is going
        to be downloaded, may be used for magnet torrents (DHT).
        :type close: bool
        :param close: If the server infra-structure should be close (process ends)
        at the end of the download, this is not the default behavior (multiple download).
        :rtype: TorrentTask
        :return: The torrent task object that represents the task that has been
        created for downloading of the requested file.
        """
        ...
    
    def add_task(self, task): # -> None:
        ...
    
    def remove_task(self, task): # -> None:
        ...
    
    def cleanup_tasks(self): # -> None:
        ...
    


if __name__ == "__main__":
    def on_start(server): # -> None:
        ...
    
    def on_piece(task, index): # -> None:
        ...
    
    def on_complete(task): # -> None:
        ...
    
    server = ...
else:
    __path__ = ...
