"""
This type stub file was generated by pyright.
"""

import netius.servers

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
DEFAULT_NAME = ...
class ReverseProxyServer(netius.servers.ProxyServer):
    """
    Reverse HTTP proxy implementation based on the more generalized
    infra-structure of proxy server.

    Supports multiple scheduling strategies, being the "smart" one
    the most efficient for most of the possible scenarios.

    Conditional re-usage of connections based on boolean flag is possible,
    but care should be taken when using re-usage so that no multiple
    rules are applied for the same connection (eg: https://host.com/hive,
    https://host.com/colony as different rules), this would pose serious
    problems if the back-end servers are different for each rule or if
    the way the final back-end URL is created is different for each rule.
    """
    def __init__(self, config=..., regex=..., hosts=..., alias=..., auth=..., auth_regex=..., redirect=..., redirect_regex=..., error_urls=..., forward=..., strategy=..., reuse=..., sts=..., resolve=..., resolve_t=..., host_f=..., echo=..., *args, **kwargs) -> None:
        ...
    
    def info_dict(self, full=...): # -> dict[str, str | Any]:
        ...
    
    def proxy_r_dict(self): # -> dict[str, dict[Any, Any] | None]:
        ...
    
    def on_diag(self): # -> None:
        ...
    
    def on_start(self): # -> None:
        ...
    
    def on_serve(self): # -> None:
        ...
    
    def on_headers(self, connection, parser):
        ...
    
    def rules(self, url, parser): # -> tuple[None, None] | tuple[Any, Any | None] | tuple[Any, None] | Any:
        ...
    
    def rules_regex(self, url, parser): # -> tuple[None, None] | tuple[Any, Any | None]:
        ...
    
    def rules_host(self, url, parser): # -> tuple[Any, None] | Any:
        ...
    
    def rules_forward(self, url, parser): # -> tuple[Any, None] | Any:
        ...
    
    def balancer(self, values): # -> tuple[Any, None] | Any:
        ...
    
    def balancer_robin(self, values): # -> tuple[Any, None]:
        ...
    
    def balancer_smart(self, values): # -> tuple[Any, tuple[Any, PriorityDict | Any]]:
        ...
    
    def acquirer(self, state): # -> None:
        ...
    
    def acquirer_robin(self, state): # -> None:
        ...
    
    def acquirer_smart(self, state): # -> None:
        ...
    
    def releaser(self, state): # -> None:
        ...
    
    def releaser_robin(self, state): # -> None:
        ...
    
    def releaser_smart(self, state): # -> None:
        ...
    
    def dns_start(self, timeout=...): # -> None:
        ...
    
    def dns_tick(self, timeout=...): # -> None:
        ...
    
    def dns_callback(self, host, hostname, parsed, index=..., resolved=...): # -> Callable[..., None]:
        ...
    


if __name__ == "__main__":
    regex = ...
    hosts = ...
    alias = ...
    auth = ...
    auth_regex = ...
    redirect = ...
    error_urls = ...
    server = ...
else:
    __path__ = ...
