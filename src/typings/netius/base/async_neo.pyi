import netius.base.async_old
import netius.base.async_old as async_old
import netius.base.errors as errors
import netius.base.legacy as legacy
from _typeshed import Incomplete
from typing import ClassVar

__version__: str
__revision__: str
__date__: str

class Future(netius.base.async_old.Future):
    def __iter__(self): ...
    def __await__(self): ...

class AwaitWrapper:
    _is_generator: ClassVar[bool] = ...
    def __init__(self, generator, generate: bool = ...) -> None: ...
    def __await__(self): ...
    def __iter__(self): ...
    def __next__(self): ...
    def next(self): ...
    def generate(self, value): ...
    def _await_generator(self): ...
    def _await_basic(self): ...

class CoroutineWrapper:
    def __init__(self, coroutine) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...
    def next(self): ...
    def restore(self, value): ...
def coroutine(function): ...
def ensure_generator(value): ...
def get_asyncio(): ...
def is_coroutine(callable): ...
def is_coroutine_object(generator): ...
def is_coroutine_native(generator): ...
def is_future(future): ...
def _sleep(timeout, compat: bool = ...): ...
def _wait(event, timeout: Incomplete | None = ..., future: Incomplete | None = ...): ...
def sleep(*args, **kwargs): ...
def wait(*args, **kwargs): ...
def coroutine_return(coroutine): ...
def _coroutine_return(coroutine): ...
