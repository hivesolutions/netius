"""
This type stub file was generated by pyright.
"""

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
asyncio = ...
BaseLoop = ...
class CompatLoop(BaseLoop):
    """
    Top level compatibility class that adds compatibility support
    for the asyncio event loop strategy.

    This is required to be able to access netius event loop on a
    asyncio like manner.

    :see: https://docs.python.org/3/library/asyncio-eventloop.html
    """
    def __init__(self, loop) -> None:
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    def time(self): # -> float:
        ...
    
    def call_soon(self, callback, *args): # -> Handle:
        ...
    
    def call_soon_threadsafe(self, callback, *args): # -> Handle:
        ...
    
    def call_at(self, when, callback, *args): # -> Handle:
        ...
    
    def call_later(self, delay, callback, *args): # -> Handle:
        """
        Calls the provided callback with the provided parameters after
        the defined delay (in seconds), should ensure proper sleep operation.

        :type delay: float
        :param delay: The delay in seconds after which the callback is going
        to be called with the provided arguments.
        :type callback: Function
        :param callback: The function to be called after the provided delay.
        :rtype: Handle
        :return: The handle object to the operation, that may be used to cancel it.
        """
        ...
    
    def create_future(self): # -> Any:
        ...
    
    def create_task(self, coroutine): # -> Task:
        ...
    
    def create_server(self, *args, **kwargs): # -> AwaitWrapper:
        ...
    
    def create_connection(self, *args, **kwargs): # -> AwaitWrapper:
        ...
    
    def create_datagram_endpoint(self, *args, **kwargs): # -> AwaitWrapper:
        ...
    
    def getaddrinfo(self, *args, **kwargs): # -> AwaitWrapper:
        ...
    
    def getnameinfo(self, *args, **kwargs): # -> AwaitWrapper:
        ...
    
    def run_until_complete(self, future): # -> Any:
        ...
    
    def run_forever(self): # -> Any:
        ...
    
    def run_in_executor(self, *args, **kwargs): # -> AwaitWrapper:
        ...
    
    def stop(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def get_exception_handler(self): # -> Callable[..., None]:
        ...
    
    def set_exception_handler(self, handler): # -> None:
        ...
    
    def default_exception_handler(self, context): # -> None:
        ...
    
    def call_exception_handler(self, context): # -> None:
        ...
    
    def get_debug(self): # -> Any:
        ...
    
    def set_debug(self, enabled): # -> None:
        ...
    
    def set_default_executor(self, executor): # -> None:
        ...
    
    def get_task_factory(self): # -> type[Task]:
        ...
    
    def set_task_factory(self, factory): # -> None:
        ...
    
    def is_running(self): # -> Any:
        ...
    
    def is_closed(self): # -> Any:
        ...
    


def is_compat(): # -> bool:
    """
    Determines if the compatibility mode for the netius
    event loop is required.

    Under this mode the event loop for netius tries to emulate
    the behaviour of the asyncio event loop so that it may
    be used with 3rd party protocol classes (not compliant
    with the netius protocol).

    :rtype: bool
    :return: If the netius infra-structure should run under
    the compatibility mode.
    """
    ...

def is_asyncio(): # -> bool:
    """
    Checks if the asyncio mode of execution (external event
    loop) is the required approach under the current runtime.

    If that's the case the netius event loop is not going to
    be used and the asyncio one is going to be used instead.

    :rtype: bool
    :return: If the asyncio event loop model is enabled and
    proper library support available.
    """
    ...

def build_datagram(*args, **kwargs): # -> AbstractEventLoop | None:
    ...

def connect_stream(*args, **kwargs): # -> AbstractEventLoop | None:
    ...

