import netius as netius
import netius.base.async_old as async_old
import netius.base.asynchronous as asynchronous
import netius.base.common
import netius.base.compat as compat
import netius.base.config as config
import netius.base.errors as errors
import netius.base.legacy as legacy
import netius.base.log as log
import netius.base.observer as observer
import netius.base.request as request
import netius.base.tls as tls
import netius.base.util as util
import netius.middleware as middleware
import socket
from _typeshed import Incomplete
from netius.base.async_neo import AwaitWrapper as AwaitWrapper, CoroutineWrapper as CoroutineWrapper, Future as Future, coroutine as coroutine, coroutine_return as coroutine_return, ensure_generator as ensure_generator, get_asyncio as get_asyncio, is_coroutine as is_coroutine, is_coroutine_native as is_coroutine_native, is_coroutine_object as is_coroutine_object, is_future as is_future, sleep as sleep, wait as wait
from netius.base.async_old import Executor as Executor, Handle as Handle, Task as Task, ThreadPoolExecutor as ThreadPoolExecutor, async_test as async_test, async_test_all as async_test_all, is_asynclib as is_asynclib, is_await as is_await, is_neo as is_neo, notify as notify, wakeup as wakeup
from netius.base.common import AbstractBase as AbstractBase, Base as Base, BaseThread as BaseThread, DiagBase as DiagBase, build_future as build_future, compat_loop as compat_loop, ensure as ensure, ensure_asyncio as ensure_asyncio, ensure_loop as ensure_loop, ensure_main as ensure_main, ensure_pool as ensure_pool, get_event_loop as get_event_loop, get_loop as get_loop, get_main as get_main, get_poll as get_poll, new_loop as new_loop, new_loop_asyncio as new_loop_asyncio, new_loop_main as new_loop_main, stop_loop as stop_loop
from netius.base.conn import BaseConnection as BaseConnection, Connection as Connection, DiagConnection as DiagConnection
from netius.base.poll import EpollPoll as EpollPoll, KqueuePoll as KqueuePoll, Poll as Poll, PollPoll as PollPoll, SelectPoll as SelectPoll
from typing import ClassVar

__version__: str
__revision__: str
__date__: str
OPEN: int
CLOSED: int
PENDING: int
CHUNK_SIZE: int
is_diag: bool
POLL_TIMEOUT: float
NAME: str
VERSION: str
PLATFORM: str
IDENTIFIER_TINY: str
IDENTIFIER_SHORT: str
IDENTIFIER_LONG: str
IDENTIFIER: str
WSAEWOULDBLOCK: int
WSAECONNABORTED: int
WSAECONNRESET: int
SSL_ERROR_CERT_ALREADY_IN_HASH_TABLE: int
POLL_ORDER: tuple
SILENT_ERRORS: tuple
VALID_ERRORS: tuple
SSL_SILENT_ERRORS: tuple
SSL_VALID_ERRORS: tuple
SSL_ERROR_NAMES: dict
SSL_VALID_REASONS: tuple
TCP_TYPE: int
UDP_TYPE: int
STATE_STOP: int
STATE_START: int
STATE_PAUSE: int
STATE_CONFIG: int
STATE_POLL: int
STATE_TICK: int
STATE_READ: int
STATE_WRITE: int
STATE_ERRROR: int
STATE_STRINGS: tuple
KEEPALIVE_TIMEOUT: int
KEEPALIVE_INTERVAL: int
KEEPALIVE_COUNT: int
ALLOW_BLOCK: bool
LOG_FORMAT: str
BASE_PATH: str
EXTRAS_PATH: str
SSL_KEY_PATH: str
SSL_CER_PATH: str
SSL_CA_PATH: None
SSL_DH_PATH: str
BUFFER_SIZE: None
GC_TIMEOUT: float

class Client(netius.base.common.AbstractBase):
    _client: ClassVar[None] = ...
    def __init__(self, thread: bool = ..., daemon: bool = ..., *args, **kwargs) -> None: ...
    @classmethod
    def get_client_s(cls, *args, **kwargs): ...
    @classmethod
    def cleanup_s(cls): ...
    def ensure_loop(self, env: bool = ...): ...
    def join(self, timeout: Incomplete | None = ...): ...

class DatagramClient(Client):
    def __init__(self, *args, **kwargs) -> None: ...
    def boot(self): ...
    def cleanup(self): ...
    def on_read(self, _socket): ...
    def on_write(self, _socket): ...
    def on_error(self, _socket): ...
    def on_exception(self, exception): ...
    def on_expected(self, exception): ...
    def on_data(self, connection, data): ...
    def keep_gc(self, timeout: float = ..., run: bool = ...): ...
    def gc(self, callbacks: bool = ...): ...
    def add_request(self, request): ...
    def remove_request(self, request): ...
    def get_request(self, id): ...
    def ensure_socket(self): ...
    def ensure_write(self): ...
    def remove_write(self): ...
    def enable_read(self): ...
    def disable_read(self): ...
    def send(self, data, address, delay: bool = ..., ensure_loop: bool = ..., callback: Incomplete | None = ...): ...
    def _send(self, _socket): ...
    def _flush_write(self): ...

class StreamClient(Client):
    def __init__(self, *args, **kwargs) -> None: ...
    def cleanup(self): ...
    def ticks(self): ...
    def info_dict(self, full: bool = ...): ...
    def acquire_c(self, host, port, ssl: bool = ..., key_file: Incomplete | None = ..., cer_file: Incomplete | None = ..., validate: bool = ..., callback: Incomplete | None = ...): ...
    def release_c(self, connection): ...
    def remove_c(self, connection): ...
    def validate_c(self, connection, close: bool = ...): ...
    def connect(self, host, port, ssl: bool = ..., key_file: Incomplete | None = ..., cer_file: Incomplete | None = ..., ca_file: Incomplete | None = ..., ca_root: bool = ..., ssl_verify: bool = ..., family: socket.AddressFamily = ..., type: socket.SocketKind = ..., ensure_loop: bool = ..., env: bool = ...): ...
    def acquire(self, connection): ...
    def on_read(self, _socket): ...
    def on_write(self, _socket): ...
    def on_error(self, _socket): ...
    def on_exception(self, exception, connection): ...
    def on_expected(self, exception, connection): ...
    def on_connect(self, connection): ...
    def on_upgrade(self, connection): ...
    def on_ssl(self, connection): ...
    def on_acquire(self, connection): ...
    def on_release(self, connection): ...
    def on_data(self, connection, data): ...
    def _connectf(self, connection): ...
    def _connects(self): ...
    def _connect(self, connection): ...
    def _ssl_handshake(self, connection): ...
