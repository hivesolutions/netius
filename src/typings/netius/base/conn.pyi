"""
This type stub file was generated by pyright.
"""

from . import observer

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
OPEN = ...
CLOSED = ...
PENDING = ...
CHUNK_SIZE = ...
class BaseConnection(observer.Observable):
    """
    Abstract connection object that should encapsulate
    a socket object enabling it to be accessed in much
    more "protected" way avoiding possible sync problems.

    It should also abstract the developer from all the
    select associated complexities adding and removing the
    underlying socket from the selecting mechanism for the
    appropriate operations.
    """
    def __init__(self, owner=..., socket=..., address=..., datagram=..., ssl=..., max_pending=..., min_pending=...) -> None:
        ...
    
    def destroy(self): # -> None:
        ...
    
    def open(self, connect=...): # -> None:
        ...
    
    def close(self, flush=..., destroy=...): # -> None:
        ...
    
    def close_flush(self): # -> None:
        ...
    
    def upgrade(self, key_file=..., cer_file=..., ca_file=..., server=...): # -> None:
        ...
    
    def set_connecting(self): # -> None:
        ...
    
    def set_connected(self): # -> None:
        ...
    
    def set_upgraded(self): # -> None:
        ...
    
    def set_data(self, data, address=...): # -> None:
        ...
    
    def ensure_write(self, flush=...): # -> None:
        ...
    
    def remove_write(self): # -> None:
        ...
    
    def enable_read(self): # -> None:
        """
        Enables read operations for the current connection
        this will set the read enable flag and then subscribe
        to the read operations in case the underlying poll
        method is not of type edge (level based).

        This is a dangerous operation as it may cause the system
        to stall if misused.
        """
        ...
    
    def disable_read(self): # -> None:
        """
        Disables any read operation on the current socket, does that
        by disabling the current read enable and then unsubscribing
        the current connection from the read operation.

        This is an extremely dangerous operation and the correct knowledge
        of the event poll is required to avoid stalling.
        """
        ...
    
    def send(self, data, address=..., delay=..., force=..., callback=...): # -> int:
        """
        The main send call to be used by a proxy connection and
        from different threads.

        This method is the equivalent on a socket basis to both the
        send and the send to method, meaning that datagram send operations
        are also allowed by using the address parameter.

        In case the sending should be forced as delayed (next tick)
        the delay flag should be set and the sending will be delayed.
        This is especially useful to avoid a stack overflow situation
        because of extended callback calling, for example while sending
        very large chunks of information (eg: multi megabyte files).

        An optional callback attribute may be sent, so that when the
        send is complete it's called with a reference to the data object.

        Calling this method should be done with care as this can
        create dead lock or socket corruption situations, extreme
        knowledge of the internals of the system is required.

        :type data: String
        :param data: The buffer containing the data to be sent
        through this connection to the other endpoint.
        :type address: Tuple
        :param address: The target address for the send operation,
        this is relevant only for datagram based connections.
        :type delay: bool
        :param delay: If the send operation should be delayed until
        the next tick operation or if it should be performed as
        soon as possible (as defined in specification).
        :type force: bool
        :param force: If the sending of the data should be "forced",
        meaning that even if the connection is not open the data
        is added to the current pending queue. Useful for client
        connections wanting to write ahead.
        :type callback: Function
        :param callback: Function to be called when the data set
        to be send is completely sent to the socket.
        """
        ...
    
    def recv(self, size=..., force=...): # -> Literal[b""]:
        ...
    
    def pend(self, data, back=...): # -> None:
        ...
    
    def restore(self, data, back=...): # -> None:
        """
        Restore data to the pending (to receive) so that they are
        going to be "received" in the next receive operation.

        :type data: String
        :param data: The buffer of data that is going to be restored
        to the internal receive buffers.
        :type back: bool
        :param back: If the data should be restore to the "back" of
        the internal buffers, or if instead it should be added to the
        front (next to be received) part of the buffer.
        """
        ...
    
    def run_starter(self): # -> bool:
        ...
    
    def end_starter(self): # -> None:
        ...
    
    def add_starter(self, starter, back=...): # -> None:
        ...
    
    def remove_starter(self, starter): # -> None:
        ...
    
    def info_dict(self, full=...): # -> dict[str, Any | None]:
        ...
    
    def ssl_certificate(self, binary=...): # -> None:
        ...
    
    def ssl_verify_host(self, host=...): # -> None:
        ...
    
    def ssl_verify_fingerprint(self, fingerprint=...): # -> None:
        ...
    
    def ssl_dump_certificate(self, dump=...): # -> None:
        ...
    
    def ssl_protocol(self): # -> None:
        ...
    
    def ssl_alpn_protocol(self): # -> None:
        ...
    
    def ssl_npn_protocol(self): # -> None:
        ...
    
    def is_open(self): # -> bool:
        ...
    
    def is_closed(self): # -> bool:
        ...
    
    def is_pending(self): # -> bool:
        ...
    
    def is_connected(self): # -> bool:
        ...
    
    def is_connecting(self): # -> bool:
        ...
    
    def is_upgrading(self): # -> bool:
        ...
    
    def is_throttleable(self): # -> Literal[True]:
        ...
    
    def is_exhausted(self): # -> bool:
        ...
    
    def is_restored(self): # -> bool:
        ...
    
    def is_pending_data(self): # -> bool:
        ...
    


class DiagConnection(BaseConnection):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def recv(self, *args, **kwargs): # -> Literal[b""]:
        ...
    
    def send(self, data, *args, **kwargs): # -> int:
        ...
    
    def info_dict(self, full=...): # -> dict[str, Any | None]:
        ...
    


is_diag = ...
if is_diag:
    Connection = ...
else:
    Connection = ...
