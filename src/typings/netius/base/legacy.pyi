"""
This type stub file was generated by pyright.
"""

import contextlib

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
ArgSpec = ...
@contextlib.contextmanager
def ctx_absolute(): # -> Generator[None, Any, None]:
    ...

PYTHON_3 = ...
PYTHON_35 = ...
PYTHON_36 = ...
PYTHON_39 = ...
PYTHON_ASYNC = ...
PYTHON_ASYNC_GEN = ...
PYTHON_V = ...
if PYTHON_3:
    LONG = ...
else:
    LONG = ...
if PYTHON_3:
    BYTES = ...
else:
    BYTES = ...
if PYTHON_3:
    UNICODE = ...
else:
    UNICODE = ...
if PYTHON_3:
    OLD_UNICODE = ...
else:
    OLD_UNICODE = ...
if PYTHON_3:
    STRINGS = ...
else:
    STRINGS = ...
if PYTHON_3:
    ALL_STRINGS = ...
else:
    ALL_STRINGS = ...
if PYTHON_3:
    INTEGERS = ...
else:
    INTEGERS = ...
_ord = ...
_chr = ...
_str = str
_bytes = bytes
_range = range
_xrange = ...
if PYTHON_3:
    Request = ...
else:
    Request = ...
if PYTHON_3:
    HTTPHandler = ...
else:
    HTTPHandler = ...
if PYTHON_3:
    HTTPError = ...
else:
    HTTPError = ...
if PYTHON_3:
    HTTPConnection = ...
else:
    HTTPConnection = ...
if PYTHON_3:
    HTTPSConnection = ...
else:
    HTTPSConnection = ...
_execfile = ...
_reduce = ...
_reload = ...
_unichr = ...
def with_meta(meta, *bases):
    ...

def eager(iterable): # -> list[Any]:
    ...

def iteritems(associative):
    ...

def iterkeys(associative):
    ...

def itervalues(associative):
    ...

def items(associative): # -> list[Any]:
    ...

def keys(associative): # -> list[Any]:
    ...

def values(associative): # -> list[Any]:
    ...

def xrange(start, stop=..., step=...): # -> _range:
    ...

def range(start, stop=..., step=...): # -> list[Any] | _range:
    ...

def ord(value): # -> int:
    ...

def chr(value): # -> _bytes | str:
    ...

def chri(value): # -> str:
    ...

def bytes(value, encoding=..., errors=..., force=...): # -> _bytes:
    ...

def str(value, encoding=..., errors=..., force=...):
    ...

def u(value, encoding=..., errors=..., force=...):
    ...

def ascii(value, encoding=..., errors=...): # -> bytes | str:
    ...

def orderable(value): # -> Orderable:
    ...

def is_str(value): # -> Any:
    ...

def is_unicode(value): # -> Any:
    ...

def is_bytes(value): # -> Any:
    ...

def is_string(value, all=...): # -> bool:
    ...

def is_generator(value): # -> bool:
    ...

def is_async_generator(value): # -> bool:
    ...

def is_unittest(name=...): # -> bool:
    ...

def execfile(path, global_vars, local_vars=..., encoding=...): # -> None:
    ...

def walk(path, visit, arg): # -> None:
    ...

def getargspec(func): # -> ArgSpec:
    ...

def has_module(name): # -> bool:
    ...

def new_module(name): # -> ModuleType:
    ...

def reduce(*args, **kwargs):
    ...

def reload(*args, **kwargs): # -> ModuleType:
    ...

def unichr(*args, **kwargs): # -> str:
    ...

def urlopen(*args, **kwargs): # -> _UrlopenRet:
    ...

def build_opener(*args, **kwargs): # -> OpenerDirector:
    ...

def urlparse(*args, **kwargs):
    ...

def urlunparse(*args, **kwargs): # -> Literal[b""]:
    ...

def parse_qs(*args, **kwargs): # -> dict[Any, list[Any]]:
    ...

def urlencode(*args, **kwargs): # -> str:
    ...

def quote(*args, **kwargs): # -> str:
    ...

def quote_plus(*args, **kwargs): # -> str:
    ...

def unquote(*args, **kwargs): # -> str:
    ...

def unquote_plus(*args, **kwargs): # -> str:
    ...

def cmp_to_key(*args, **kwargs): # -> dict[str, Callable[[Any], SupportsAllComparisons]] | dict[str, Any]:
    ...

def tobytes(self, *args, **kwargs):
    ...

def tostring(self, *args, **kwargs):
    ...

def StringIO(*args, **kwargs): # -> StringIO:
    ...

def BytesIO(*args, **kwargs): # -> BytesIO | StringIO:
    ...

class Orderable(tuple):
    """
    Simple tuple type wrapper that provides a simple
    first element ordering, that is compatible with
    both the Python 2 and Python 3+ infra-structures.
    """
    def __cmp__(self, value):
        ...
    
    def __lt__(self, value) -> bool:
        ...
    


