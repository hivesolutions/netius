"""
This type stub file was generated by pyright.
"""

import os
from .conn import *
from .poll import *
from .asynchronous import *

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
NAME = ...
VERSION = ...
PLATFORM = ...
IDENTIFIER_TINY = ...
IDENTIFIER_SHORT = ...
IDENTIFIER_LONG = ...
IDENTIFIER = ...
WSAEWOULDBLOCK = ...
WSAECONNABORTED = ...
WSAECONNRESET = ...
SSL_ERROR_CERT_ALREADY_IN_HASH_TABLE = ...
POLL_ORDER = ...
SILENT_ERRORS = ...
VALID_ERRORS = ...
SSL_SILENT_ERRORS = ...
SSL_VALID_ERRORS = ...
SSL_ERROR_NAMES = ...
SSL_VALID_REASONS = ...
TCP_TYPE = ...
UDP_TYPE = ...
STATE_STOP = ...
STATE_START = ...
STATE_PAUSE = ...
STATE_CONFIG = ...
STATE_POLL = ...
STATE_TICK = ...
STATE_READ = ...
STATE_WRITE = ...
STATE_ERRROR = ...
STATE_STRINGS = ...
KEEPALIVE_TIMEOUT = ...
KEEPALIVE_INTERVAL = ...
KEEPALIVE_COUNT = ...
ALLOW_BLOCK = ...
LOG_FORMAT = ...
BASE_PATH = ...
EXTRAS_PATH = ...
SSL_KEY_PATH = ...
SSL_CER_PATH = ...
SSL_CA_PATH = ...
SSL_DH_PATH = ...
if not os.path.exists(SSL_CA_PATH):
    SSL_CA_PATH = ...
if not os.path.exists(SSL_DH_PATH):
    SSL_DH_PATH = ...
class AbstractBase(observer.Observable):
    """
    Base network structure to be used by all the network
    capable infra-structures (eg: servers and clients).

    Should handle all the non blocking event loop stuff,
    so that the read and write operations are easy to handle.

    This is considered to be the main event loop code.
    """
    _MAIN = ...
    _MAIN_C = ...
    def __init__(self, name=..., handlers=..., *args, **kwargs) -> None:
        ...
    
    @classmethod
    def test_poll(cls, preferred=...): # -> type[EpollPoll] | type[KqueuePoll] | type[PollPoll] | type[SelectPoll]:
        ...
    
    @classmethod
    def get_loop(cls, compat=..., asyncio=...): # -> AbstractEventLoop | None:
        ...
    
    @classmethod
    def get_main(cls, compat=...): # -> None:
        ...
    
    @classmethod
    def get_asyncio(cls): # -> AbstractEventLoop | None:
        ...
    
    @classmethod
    def set_main(cls, instance, set_compat=...): # -> None:
        ...
    
    @classmethod
    def unset_main(cls, set_compat=...): # -> None:
        ...
    
    @classmethod
    def patch_asyncio(cls): # -> None:
        ...
    
    @classmethod
    def waitpid(cls, pid): # -> None:
        ...
    
    def destroy(self): # -> None:
        ...
    
    def call_safe(self, callable, args=..., kwargs=...): # -> None:
        """
        Calls the provided callable object using a safe strategy
        meaning that in case there's an exception raised in the
        middle of the callable execution it is going to be caught
        and the details of it logged.

        :type callable: Function
        :param callable: The callable function that is going to
        be called using the safe approach.
        :type args: List
        :param args: The normal (non keyword) arguments to be sent
        to the callable.
        :type kwargs: Dictionary
        :param kwargs: The set of keyword arguments that are going
        to be sent to the callable.
        :rtype: Object
        :return: The result of the calling of the callable.
        """
        ...
    
    def wait_event(self, callable, name=...): # -> None:
        ...
    
    def unwait_event(self, callable, name=...): # -> None:
        ...
    
    def delay(self, callable, timeout=..., immediately=..., verify=..., safe=...): # -> tuple[Any | Literal[-1, 0], int, Any, int, list[bool]] | Orderable | None:
        ...
    
    def delay_s(self, callable, timeout=..., immediately=..., verify=..., wakeup=...): # -> None:
        """
        Safe version of the delay operation to be used to insert a callable
        from a different thread (implies lock mechanisms).

        This method should only be used from different threads as there's
        a huge performance impact created from using this method instead of
        the local event loop one (delay()).

        :type callable: Function
        :param callable: The callable that should be called on the next tick
        according to the event loop rules.
        :type timeout: int
        :param timeout: The timeout for the callable to be called, this value
        may not reflect an accurate value and depends greatly on the minimum
        resolution value of the polling mechanism.
        :type immediately: bool
        :param immediately: If the callable should be called as soon as possible,
        this is equivalent to setting timeout to -1.
        :type verify: bool
        :param verify: If the delayed sequences should be verified for possible
        duplicated, avoiding possible issues.
        :type wakeup: bool
        :param wakeup: If the main event loop should be awaken so that the
        callable is processed as soon as possible.
        """
        ...
    
    def delay_m(self): # -> None:
        """
        Runs the merge operation so that the delay next list (used by the delay
        safe operation) is merged with the delayed and the delayed ordered
        structures, making the events (effectively) ready to be executed by delays.
        """
        ...
    
    def ensure(self, coroutine, args=..., kwargs=..., thread=..., future=..., immediately=...): # -> Future:
        """
        Main method for the queuing/startup of an asynchronous coroutine
        of async method, this should be called at the most higher level
        of the execution of a chained coroutine sequence.

        It should ensure that the provided callable is wrapped into a
        coroutine if that's the case, so that chained calling is not
        violated by a non compliant element.

        The method should create a proper sequence/pipelined handling of
        the various chained coroutine calls so that they are called one
        after the other using futures for such handling. The final "simple"
        abstraction should expose one "parent" future object as the interface.

        Multiple calls to this method should generate different async
        contexts (with different parent future instances).

        :type coroutine: Coroutine/CoroutineObject/Callable
        :param coroutine: The callable or coroutine that is going to be
        "inserted" for an asynchronous execution, if a callable is provided
        a coroutine is created wrapping the execution of such callable.
        :type args: List
        :param args: The list of "normal" arguments to be sent to the
        coroutine as parts of its signature.
        :type kwargs: Dictionary
        :param kwargs: The keyword arguments to be sent to the coroutine.
        :type thread: bool
        :param thread: If the execution of the coroutine should be done
        using a different thread (via thread pool), this may be interesting
        if the coroutine includes blocking i/o calls.
        :type future: Future
        :param future: If provided ensures that non new future object is going
        to be created for this async context to be created.
        :type immediately: bool
        :param immediately: If the callback should be scheduler in the event
        pool to be executed immediately (as soon as possible).
        :rtype: Future
        :return: The future that has been created for this new async context
        or the provided one if one was provided (this is considered to be the
        parent future of the complete coroutine chain).
        """
        ...
    
    def resolve_hostname(self, hostname, type=...): # -> Future:
        """
        Resolve the provided hostname according to the provided type
        resolution. The resolution process itself is asynchronous and
        implementation independent, returning a future for the control
        of the execution.

        :type hostname: String
        :param hostname: The name of the host to be resolved.
        :type type: String
        :param type: The type of resolutions to be used (eg: a, aaaa, mx, etc.)
        :rtype: Future
        :return: The future to be used in the operation execution.
        """
        ...
    
    def run_forever(self): # -> None:
        ...
    
    def run_coroutine(self, coroutine, args=..., kwargs=..., thread=..., close=...): # -> None:
        ...
    
    def wakeup(self, force=...): # -> None:
        ...
    
    def sleep(self, timeout, future=...): # -> Future:
        ...
    
    def wait(self, event, timeout=..., future=...): # -> Future:
        ...
    
    def notify(self, event, data=...): # -> None:
        ...
    
    def load(self, full=...): # -> None:
        """
        Starts the loading process for the current engine, this should be
        a singleton (run once) operation to be executed once per instance.

        Some of the responsibilities of the loading process should include:
        logging loading, system signal binding and welcome message printing.

        The method should be protected against double execution issues, meaning
        that should be safely called at any stage of the life cycle.

        :type full: bool
        :param full: If the loading process should be performed completely,
        meaning that even the long tasks should be executed.
        """
        ...
    
    def unload(self, full=...): # -> None:
        """
        Unloads the structures associated with the current engine, so that
        the state of the current engine is reversed to the original one.

        Note that this is not related in any way with the event loop and only
        static structures are affected.

        After a call to this method, the load method may be called again.

        :type full: bool
        :param full: If the complete set of structure unloading operations
        should be performed, this is related with the full flag of load.
        """
        ...
    
    def boot(self): # -> None:
        ...
    
    def welcome(self): # -> None:
        ...
    
    def load_logging(self, level=..., format=..., unique=...): # -> None:
        ...
    
    def unload_logging(self, safe=...): # -> None:
        ...
    
    def extra_logging(self, level, formatter): # -> None:
        """
        Loads the complete set of logging handlers defined in the
        current logging value, should be a map of definitions.

        This handlers will latter be used for piping the various
        logging messages to certain output channels.

        The creation of the handler is done using a special keyword
        arguments strategy so that python and configuration files
        are properly set as compatible.

        :type level: String/int
        :param level: The base severity level for which the new handler
        will be configured in case no extra level definition is set.
        :type formatter: Formatter
        :param formatter: The logging formatter instance to be set in
        the handler for formatting messages to the output.
        """
        ...
    
    def level_logging(self, level): # -> None:
        """
        Changes the verbosity level of the current logging infra-structure
        into the provided level of verbosity.

        The provided value may be an integer (internal value) or a string
        representation of the requested verbosity level.

        :type level: int/String
        :param level: The (logging) for which the logging infra-structure
        must be changed, either an integer or string value.
        """
        ...
    
    def load_diag(self, env=...): # -> None:
        ...
    
    def load_middleware(self, suffix=...): # -> None:
        ...
    
    def unload_middleware(self): # -> None:
        ...
    
    def register_middleware(self, middleware_c, *args, **kwargs):
        ...
    
    def call_middleware(self, name, *args, **kwargs): # -> None:
        ...
    
    def bind_signals(self, signals=..., handler=...): # -> None:
        ...
    
    def unbind_signals(self, signals=...): # -> None:
        ...
    
    def bind_env(self): # -> None:
        """
        Binds the current environment values to the current instance.
        This method has a global behaviour on the current event loop.
        """
        ...
    
    def forever(self, env=...): # -> None:
        ...
    
    def start(self): # -> None:
        ...
    
    def stop(self): # -> None:
        ...
    
    def pause(self): # -> None:
        ...
    
    def resume(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def finish(self): # -> None:
        ...
    
    def main(self): # -> None:
        ...
    
    def is_main(self): # -> bool:
        ...
    
    def is_running(self): # -> bool:
        ...
    
    def is_started(self):
        ...
    
    def is_stopped(self):
        ...
    
    def is_paused(self):
        ...
    
    def is_edge(self): # -> bool:
        ...
    
    def is_empty(self): # -> bool:
        ...
    
    def is_sub_read(self, socket): # -> bool:
        ...
    
    def is_sub_write(self, socket): # -> bool:
        ...
    
    def is_sub_error(self, socket): # -> bool:
        ...
    
    def sub_all(self, socket): # -> None:
        ...
    
    def unsub_all(self, socket): # -> None:
        ...
    
    def sub_read(self, socket): # -> None:
        ...
    
    def sub_write(self, socket): # -> None:
        ...
    
    def sub_error(self, socket): # -> None:
        ...
    
    def unsub_read(self, socket): # -> None:
        ...
    
    def unsub_write(self, socket): # -> None:
        ...
    
    def unsub_error(self, socket): # -> None:
        ...
    
    def cleanup(self, destroy=...): # -> None:
        ...
    
    def loop(self): # -> None:
        ...
    
    def block(self): # -> None:
        """
        Runs the sub-blocking operation, by "forking" the current loop
        execution into an inner one for a new context.

        The execution of this method is not recommended and should be
        used with extreme care to avoid unwanted behaviour.
        """
        ...
    
    def fork(self, timeout=...): # -> bool:
        ...
    
    def finalize(self): # -> None:
        ...
    
    def ticks(self): # -> None:
        ...
    
    def reads(self, reads, state=...): # -> None:
        ...
    
    def writes(self, writes, state=...): # -> None:
        ...
    
    def errors(self, errors, state=...): # -> None:
        ...
    
    def datagram(self, family=..., type=..., local_host=..., local_port=..., remote_host=..., remote_port=..., callback=...): # -> BaseConnection:
        """
        Builds a datagram based connection for the provided family and
        type of socket, receiving an optional callback parameter to
        be called once the "connection" object is ready to be used.

        :type family: int
        :param family: The kind of socket family that is going to be
        used in the creation of the datagram "connection".
        :type type: int
        :param type: Socket type (datagram, stream, etc.) to be used
        for the creation of the datagram connection, in principle should
        not be changed from the default value.
        :type local_host: String
        :param local_host: The locale host to be used in a possible bind
        operation in the datagram so that the the socket listens to new
        incoming datagrams on that host.
        :type local_port: String
        :param local_host: The local port to be used in a possible bind
        operation in the datagram so that the the socket listens to new
        incoming datagrams on that port.
        :type remote_host: String
        :param remote_host: The remote host to be used in a possible connect
        (bind) operation in the datagram so that the default send operation
        does not require explicit host setting.
        :type remote_port: String
        :param remote_port: The remote port to be used in a possible connect
        (bind) operation in the datagram so that the default send operation
        does not require explicit port setting.
        :type callback: Function
        :param callback: Callback function to be called once the datagram
        connection is considered to be ready.
        :rtype: Connection
        :return: The datagram based connection that encapsulates the datagram
        based connection logic.
        """
        ...
    
    def connect(self, host, port, receive_buffer=..., send_buffer=..., ssl=..., key_file=..., cer_file=..., ca_file=..., ca_root=..., ssl_verify=..., family=..., type=..., callback=..., env=...):
        ...
    
    def acquire(self, connection): # -> None:
        ...
    
    def pregister(self, pool): # -> None:
        ...
    
    def punregister(self, pool): # -> None:
        ...
    
    def pcallback(self, event, socket, pool): # -> None:
        ...
    
    def nensure(self): # -> None:
        ...
    
    def nstart(self): # -> None:
        ...
    
    def nstop(self): # -> None:
        ...
    
    def tensure(self): # -> None:
        ...
    
    def tstart(self): # -> None:
        ...
    
    def tstop(self): # -> None:
        ...
    
    def texecute(self, callable, args=..., kwargs=..., callback=...): # -> None:
        ...
    
    def files(self): # -> None:
        ...
    
    def fopen(self, *args, **kwargs): # -> None:
        ...
    
    def fclose(self, *args, **kwargs): # -> None:
        ...
    
    def fread(self, *args, **kwargs): # -> None:
        ...
    
    def fwrite(self, *args, **kwargs): # -> None:
        ...
    
    def fensure(self): # -> None:
        ...
    
    def fstart(self): # -> None:
        ...
    
    def fstop(self): # -> None:
        ...
    
    def on_connection_c(self, connection): # -> None:
        ...
    
    def on_connection_d(self, connection): # -> None:
        ...
    
    def on_stream_c(self, stream): # -> None:
        ...
    
    def on_stream_d(self, stream): # -> None:
        ...
    
    def on_fork(self): # -> None:
        ...
    
    def on_join(self): # -> None:
        ...
    
    def on_child(self, pipe=...): # -> None:
        ...
    
    def on_command(self, command): # -> None:
        ...
    
    def on_diag(self): # -> None:
        ...
    
    def on_start(self): # -> None:
        ...
    
    def on_stop(self): # -> None:
        ...
    
    def on_pause(self): # -> None:
        ...
    
    def on_resume(self): # -> None:
        ...
    
    def on_read(self, _socket):
        ...
    
    def on_write(self, _socket): # -> None:
        ...
    
    def on_error(self, _socket): # -> None:
        ...
    
    def on_exception(self, exception, connection): # -> None:
        ...
    
    def on_expected(self, exception, connection): # -> None:
        ...
    
    def on_connect(self, connection): # -> None:
        ...
    
    def on_upgrade(self, connection): # -> None:
        ...
    
    def on_client_ssl(self, connection): # -> None:
        ...
    
    def on_acquire(self, connection): # -> None:
        ...
    
    def on_acquire_base(self, connection): # -> None:
        ...
    
    def on_release(self, connection): # -> None:
        ...
    
    def on_release_base(self, connection): # -> None:
        ...
    
    def on_data(self, connection, data): # -> None:
        ...
    
    def on_data_base(self, connection, data): # -> None:
        ...
    
    def info_dict(self, full=...): # -> dict[str, str | Any]:
        ...
    
    def info_string(self, full=..., safe=...): # -> str:
        ...
    
    def connections_dict(self, full=...): # -> list[Any]:
        ...
    
    def connection_dict(self, id, full=...): # -> None:
        ...
    
    def build_connection(self, socket, address=..., datagram=..., ssl=...): # -> BaseConnection:
        """
        Creates a new connection for the provided socket
        object and string based address, the returned
        value should be a workable object.

        :type socket: Socket
        :param socket: The socket object to be encapsulated
        by the object to be created (connection).
        :type address: String
        :param address: The address as a string to be used to
        describe the connection object to be created.
        :type datagram: bool
        :param datagram: If the connection to be created should
        be datagram based or not.
        :type ssl: bool
        :param ssl: If the connection to be created is meant to
        be secured using the SSL framework for encryption.
        :rtype: Connection
        :return: The connection object that encapsulates the
        provided socket and address values.
        """
        ...
    
    def base_connection(self, *args, **kwargs): # -> BaseConnection:
        ...
    
    def new_connection(self, connection): # -> None:
        ...
    
    def del_connection(self, connection): # -> None:
        ...
    
    def add_callback(self, socket, callback): # -> None:
        ...
    
    def remove_callback(self, socket, callback): # -> None:
        ...
    
    def load_config(self, path=..., **kwargs): # -> None:
        ...
    
    def apply_config(self, path, kwargs):
        ...
    
    def exec_safe(self, connection, callable, *args, **kwargs): # -> Literal[False]:
        ...
    
    def is_devel(self): # -> bool:
        """
        Verifies if the current running environment is meant to be used
        for development purposes as opposed to a production environment.

        The method should always be used in situations where some critical
        and internal information is meant to be displayed in a development
        environment but hidden in a production one.

        This method should be used at runtime as opposed to the private
        configuration based one.

        :rtype: bool
        :return: If the current environment is development oriented or
        if it's considered to be a production one (invalid result).
        """
        ...
    
    def is_debug(self): # -> bool:
        ...
    
    def is_info(self): # -> bool:
        ...
    
    def is_warning(self): # -> bool:
        ...
    
    def is_error(self): # -> bool:
        ...
    
    def is_critical(self): # -> bool:
        ...
    
    def debug(self, object): # -> None:
        ...
    
    def info(self, object): # -> None:
        ...
    
    def warning(self, object): # -> None:
        ...
    
    def error(self, object): # -> None:
        ...
    
    def critical(self, object): # -> None:
        ...
    
    def log_stack(self, method=..., info=...): # -> None:
        ...
    
    def log_info(self, method=...): # -> None:
        ...
    
    def log(self, *args, **kwargs): # -> None:
        ...
    
    def log_python_3(self, object, level=...): # -> None:
        ...
    
    def log_python_2(self, object, level=...): # -> None:
        ...
    
    def build_poll(self): # -> EpollPoll | KqueuePoll | PollPoll | SelectPoll:
        ...
    
    def build_future(self, compat=..., asyncio=...): # -> Future:
        """
        Creates a future object that is bound to the current event
        loop context, this allows for latter access to the owning loop.

        :type compat: bool
        :param compat: If the compatibility mode retrieval should be used
        meaning that a compatible loop instance is retrieved instead.
        :type asyncio: bool
        :param asyncio: If the asyncio loop retrieval strategy should be
        used or if instead the netius native one should be used.
        :rtype: Future
        :return: The generated future that should be bound to the
        current context.
        """
        ...
    
    def get_id(self, unique=...): # -> str:
        ...
    
    def get_poll(self): # -> EpollPoll | KqueuePoll | PollPoll | SelectPoll:
        ...
    
    def get_poll_name(self): # -> str:
        ...
    
    def get_state(self):
        ...
    
    def set_state(self, state): # -> None:
        ...
    
    def get_state_s(self, lower=...):
        """
        Retrieves a string describing the current state
        of the system, this string should be as descriptive
        as possible.

        An optional parameter controls if the string should
        be lower cased or not.

        :type lower: bool
        :param lower: If the returned string should be converted
        into a lower cased version.
        :rtype: String
        :return: A string describing the current sate of the loop
        system, should be as descriptive as possible.
        """
        ...
    
    def get_env(self, name, default=..., cast=..., expand=...): # -> str | None:
        """
        Retrieves the value of the environment variable with the
        requested name, defaulting to the provided value in case
        it's not possible to find such variable.

        An optional cast type may be provided in order to cast the
        value of the environment variable in to the target type.

        An optional expand flag may be set so that the variable gets
        expanded as a file system file, for this the newline values
        should be escaped as explicit '\n' string sequences (two chars).

        Current implementation forwards the request to the current
        configuration registry so that other data providers may
        also be used in search for configuration.

        :type name: String
        :param name: The name of the environment variable that is
        meant to be retrieved from the current environment
        :type default: Object
        :param default: The default value to be returned in case
        no value is found for the provided name.
        :type cast: Type
        :param cast: The cast type to be used to cast the value
        of the requested environment variable.
        :type expand: bool
        :param expand: If the variable should be expanded as a file
        object and stored in a temporary storage, for this situation
        the resulting object should be a string with the file path.
        :rtype: Object
        :return: The value of the requested environment variable
        properly casted into the target value.
        """
        ...
    
    def expand(self, value, encoding=..., force=...): # -> str:
        """
        Expands the provided string/bytes value into a file in the
        current file system so that it may be correctly used by interfaces
        that require certain values to be file system based.

        The generated file is going to be removed on the cleanup operation
        so that no temporary file leaking occurs (garbage collection).

        In case the force value is provided the the file is created even
        for situations where the provided value is invalid/unset.

        :type value: String
        :param value: The string/bytes based value that is going to be
        expanded into a proper file system based (temporary) file.
        :type encoding: String
        :param encoding: The encoding that is going to be used to convert
        the value into a bytes based one in case the provided value is not
        bytes compliant (and must be converted).
        :type force: bool
        :param force: If the expansion operation should be performed even
        for situations where the value is considered invalid/unset.
        :rtype: String
        :return: The path to the temporary file that has just been generated
        for the expansion of the provided value.
        """
        ...
    
    def get_protocols(self): # -> None:
        """
        Retrieves the complete set of protocols (as ALPN strings) that are
        going to be handled by the current protocol infra-structure.

        :rtype: List
        :return: The list containing the complete set of protocols handled
        by the current infra-structure.
        :see: https://tools.ietf.org/html/rfc7301
        """
        ...
    
    def get_adapter(self, name=..., *args, **kwargs): # -> Any:
        """
        Retrieves an instance of a storage adapter described
        by the provided name, note that the dynamic (extra)
        arguments are going to be used in the construction of
        the adapter instance.

        :type name: String
        :param name: The name of the adapter to be retrieved
        this should be equivalent to the adapter class name.
        :rtype: Adapter
        :return: An instance (properly configured) of the
        requested adapter (defined by the name argument).
        """
        ...
    
    def get_auth(self, name=..., *args, **kwargs): # -> Any:
        """
        Gathers the proper authentication handler that is being
        requested with the provided name. The retrieved auth
        is a static class that should be used from its interface
        based on class based methods.

        The state of theses authentication (handlers) is based
        on the "global" state of the environment (no instances).

        :type name: String
        :param name: The name of the authentication (handler)
        class that should be retrieved.
        :rtype: Auth
        :return: An authentication based class that may be used
        for the interaction of authentication methods.
        """
        ...
    
    def get_connection(self, socket):
        """
        "Resolves" the connection associated with the provided socket
        returning the structured connection object for it.

        In case no connection exists the method raises an exception
        invalidating the current logic stack.

        :type socket: Socket
        :param socket: The socket for which the connection is going to
        be returned.
        :rtype: Connection
        :return: The connection object associated with the provided
        socket reference.
        """
        ...
    
    @property
    def is_parent(self): # -> bool:
        ...
    
    @property
    def is_child(self): # -> bool:
        ...
    
    @property
    def is_forked(self): # -> bool:
        ...
    


class DiagBase(AbstractBase):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def reads(self, *args, **kwargs): # -> None:
        ...
    
    def writes(self, *args, **kwargs): # -> None:
        ...
    
    def errors(self, *args, **kwargs): # -> None:
        ...
    
    def info_dict(self, full=...): # -> dict[str, str | Any]:
        ...
    


class BaseThread(threading.Thread):
    """
    The top level thread class that is meant to encapsulate
    a running base object and run it in a new context.

    This base thread may be used to run a network loop allowing
    a main thread to continue with execution logic.
    """
    def __init__(self, owner=..., daemon=..., *args, **kwargs) -> None:
        ...
    
    def run(self): # -> None:
        ...
    


def new_loop_main(factory=..., _compat=..., **kwargs): # -> CompatLoop | AbstractBase | DiagBase:
    ...

def new_loop_asyncio(**kwargs): # -> AbstractEventLoop | None:
    ...

def new_loop(factory=..., _compat=..., asyncio=..., **kwargs): # -> AbstractEventLoop | CompatLoop | AbstractBase | DiagBase | None:
    ...

def ensure_main(factory=..., **kwargs): # -> None:
    ...

def ensure_asyncio(**kwargs): # -> AbstractEventLoop | None:
    ...

def ensure_loop(factory=..., asyncio=..., **kwargs): # -> None:
    ...

def get_main(factory=..., ensure=..., **kwargs): # -> None:
    ...

def get_loop(factory=..., ensure=..., _compat=..., asyncio=..., **kwargs): # -> AbstractEventLoop | None:
    ...

def get_event_loop(*args, **kwargs): # -> AbstractEventLoop | None:
    """
    Compatibility alias function with the ``get_loop()`` function
    to ensure proper compatibility with asyncio.

    :rtype: EventLoop
    :return: The event loop for the current context of execution
    (if any) otherwise None (invalid).
    """
    ...

def stop_loop(compat=..., asyncio=...): # -> None:
    ...

def compat_loop(loop):
    """
    Retrieves the asyncio API compatible version of the provided
    loop in case such version exists in the current object, otherwise
    returns the proper object (assumed to be asyncio API compatible).

    :type loop: EventLoop
    :param loop: The base event loop object from which an asyncio
    API compatible object is meant to be retrieved.
    :rtype: EventLoop
    :return: The asyncio API compatible event loop object.
    """
    ...

def get_poll(): # -> None:
    ...

def build_future(compat=..., asyncio=...): # -> None:
    ...

def ensure(coroutine, args=..., kwargs=..., thread=...):
    ...

def ensure_pool(coroutine, args=..., kwargs=...):
    ...

is_diag = ...
if is_diag:
    Base = ...
else:
    Base = ...
