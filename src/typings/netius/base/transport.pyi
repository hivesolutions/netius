"""
This type stub file was generated by pyright.
"""

from . import observer

__author__ = ...
__version__ = ...
__revision__ = ...
__date__ = ...
__copyright__ = ...
__license__ = ...
class Transport(observer.Observable):
    """
    Decorator class to be used to add the functionality of a
    transport layer using a simplified and standard API.

    Allows adding the functionality to an internal netius
    connection (or equivalent) object.

    This approach is heavily influenced by the design of the
    asyncio Python infra-structure and should provide a mostly
    compatible interface.
    """
    def __init__(self, loop, connection, open=...) -> None:
        ...
    
    def open(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def abort(self): # -> None:
        ...
    
    def write(self, data): # -> None:
        ...
    
    def sendto(self, data, addr=...): # -> None:
        ...
    
    def get_extra_info(self, name, default=...): # -> None:
        ...
    
    def get_write_buffer_size(self):
        ...
    
    def get_write_buffer_limits(self): # -> tuple[Any, Any]:
        ...
    
    def set_handlers(self): # -> None:
        ...
    
    def set_write_buffer_limits(self, high=..., low=...): # -> None:
        """
        Sets the write buffer limits in the underlying connection
        object using the provided values.

        If the only one of the values is provided the other one is
        going to be calculated using an hardcoded ratio value.

        :type high: int
        :param high: The maximum number of bytes that can be set
        waiting in the connection internal buffer waiting to be sent
        before the connection becomes exhausted (sending blocked).
        :type low: int
        :param low: The maximum number of bytes waiting in the buffer
        before the connection send buffer is unblocked.
        """
        ...
    
    def set_extra_dict(self): # -> None:
        ...
    
    def get_protocol(self): # -> None:
        ...
    
    def set_protocol(self, protocol): # -> None:
        ...
    
    def is_closing(self): # -> bool:
        """
        Determines if the current transport/connection is closed
        or is in the process of being closed.

        A transport is considered closed in case the underlying
        connection object is not set or is closed.

        :rtype: bool
        :return: If the current transport is closed or in the process
        of being closed, if the connection is not set in the transport
        it's also considered to be closing.
        """
        ...
    


class TransportDatagram(Transport):
    """
    Abstract class to be used when creating a datagram based
    (connectionless) transport.

    This implementation reflects the decisions made for the
    netius based transport abstraction, inspired by asyncio.
    """
    ...


class TransportStream(Transport):
    """
    Abstract class to be used when creating a stream based
    (connection) transport.

    This implementation reflects the decisions made for the
    netius based transport abstraction, inspired by asyncio.
    """
    ...


