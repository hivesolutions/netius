import netius as netius
import netius.base.async_old as async_old
import netius.base.asynchronous as asynchronous
import netius.base.common
import netius.base.compat as compat
import netius.base.config as config
import netius.base.errors as errors
import netius.base.legacy as legacy
import netius.base.log as log
import netius.base.observer as observer
import netius.base.tls as tls
import netius.base.util as util
import netius.middleware as middleware
import socket
from _typeshed import Incomplete
from netius.base.async_neo import AwaitWrapper as AwaitWrapper, CoroutineWrapper as CoroutineWrapper, Future as Future, coroutine as coroutine, coroutine_return as coroutine_return, ensure_generator as ensure_generator, get_asyncio as get_asyncio, is_coroutine as is_coroutine, is_coroutine_native as is_coroutine_native, is_coroutine_object as is_coroutine_object, is_future as is_future, sleep as sleep, wait as wait
from netius.base.async_old import Executor as Executor, Handle as Handle, Task as Task, ThreadPoolExecutor as ThreadPoolExecutor, async_test as async_test, async_test_all as async_test_all, is_asynclib as is_asynclib, is_await as is_await, is_neo as is_neo, notify as notify, wakeup as wakeup
from netius.base.common import AbstractBase as AbstractBase, Base as Base, BaseThread as BaseThread, DiagBase as DiagBase, build_future as build_future, compat_loop as compat_loop, ensure as ensure, ensure_asyncio as ensure_asyncio, ensure_loop as ensure_loop, ensure_main as ensure_main, ensure_pool as ensure_pool, get_event_loop as get_event_loop, get_loop as get_loop, get_main as get_main, get_poll as get_poll, new_loop as new_loop, new_loop_asyncio as new_loop_asyncio, new_loop_main as new_loop_main, stop_loop as stop_loop
from netius.base.conn import BaseConnection as BaseConnection, Connection as Connection, DiagConnection as DiagConnection
from netius.base.poll import EpollPoll as EpollPoll, KqueuePoll as KqueuePoll, Poll as Poll, PollPoll as PollPoll, SelectPoll as SelectPoll

__version__: str
__revision__: str
__date__: str
OPEN: int
CLOSED: int
PENDING: int
CHUNK_SIZE: int
is_diag: bool
POLL_TIMEOUT: float
NAME: str
VERSION: str
PLATFORM: str
IDENTIFIER_TINY: str
IDENTIFIER_SHORT: str
IDENTIFIER_LONG: str
IDENTIFIER: str
WSAEWOULDBLOCK: int
WSAECONNABORTED: int
WSAECONNRESET: int
SSL_ERROR_CERT_ALREADY_IN_HASH_TABLE: int
POLL_ORDER: tuple
SILENT_ERRORS: tuple
VALID_ERRORS: tuple
SSL_SILENT_ERRORS: tuple
SSL_VALID_ERRORS: tuple
SSL_ERROR_NAMES: dict
SSL_VALID_REASONS: tuple
TCP_TYPE: int
UDP_TYPE: int
STATE_STOP: int
STATE_START: int
STATE_PAUSE: int
STATE_CONFIG: int
STATE_POLL: int
STATE_TICK: int
STATE_READ: int
STATE_WRITE: int
STATE_ERRROR: int
STATE_STRINGS: tuple
KEEPALIVE_TIMEOUT: int
KEEPALIVE_INTERVAL: int
KEEPALIVE_COUNT: int
ALLOW_BLOCK: bool
LOG_FORMAT: str
BASE_PATH: str
EXTRAS_PATH: str
SSL_KEY_PATH: str
SSL_CER_PATH: str
SSL_CA_PATH: None
SSL_DH_PATH: str
BUFFER_SIZE_S: None
BUFFER_SIZE_C: None

class Server(netius.base.common.AbstractBase):
    def __init__(self, *args, **kwargs) -> None: ...
    def welcome(self): ...
    def cleanup(self): ...
    def info_dict(self, full: bool = ...): ...
    def serve(self, host: Incomplete | None = ..., port: int = ..., type: int = ..., ipv6: bool = ..., ssl: bool = ..., key_file: Incomplete | None = ..., cer_file: Incomplete | None = ..., ca_file: Incomplete | None = ..., ca_root: bool = ..., ssl_verify: bool = ..., ssl_host: Incomplete | None = ..., ssl_fingerprint: Incomplete | None = ..., ssl_dump: bool = ..., setuid: Incomplete | None = ..., backlog: int = ..., load: bool = ..., start: bool = ..., env: bool = ...): ...
    def socket_tcp(self, ssl: bool = ..., key_file: Incomplete | None = ..., cer_file: Incomplete | None = ..., ca_file: Incomplete | None = ..., ca_root: bool = ..., ssl_verify: bool = ..., family: socket.AddressFamily = ..., type: socket.SocketKind = ...): ...
    def socket_udp(self, family: socket.AddressFamily = ..., type: socket.SocketKind = ...): ...
    def on_serve(self): ...

class DatagramServer(Server):
    def __init__(self, *args, **kwargs) -> None: ...
    def reads(self, reads, state: bool = ...): ...
    def writes(self, writes, state: bool = ...): ...
    def errors(self, errors, state: bool = ...): ...
    def serve(self, type: int = ..., *args, **kwargs): ...
    def on_read(self, _socket): ...
    def on_write(self, _socket): ...
    def on_error(self, _socket): ...
    def on_exception(self, exception): ...
    def on_expected(self, exception): ...
    def on_data(self, address, data): ...
    def ensure_write(self): ...
    def remove_write(self): ...
    def enable_read(self): ...
    def disable_read(self): ...
    def send(self, data, address, delay: bool = ..., callback: Incomplete | None = ...): ...
    def _send(self, _socket): ...
    def _flush_write(self): ...

class StreamServer(Server):
    def reads(self, reads, state: bool = ...): ...
    def writes(self, writes, state: bool = ...): ...
    def errors(self, errors, state: bool = ...): ...
    def serve(self, type: int = ..., *args, **kwargs): ...
    def on_read_s(self, _socket): ...
    def on_write_s(self, _socket): ...
    def on_error_s(self, _socket): ...
    def on_read(self, _socket): ...
    def on_write(self, _socket): ...
    def on_error(self, _socket): ...
    def on_exception(self, exception, connection): ...
    def on_exception_s(self, exception): ...
    def on_expected(self, exception, connection): ...
    def on_expected_s(self, exception): ...
    def on_upgrade(self, connection): ...
    def on_ssl(self, connection): ...
    def on_data(self, connection, data): ...
    def on_socket_c(self, socket_c, address): ...
    def on_socket_d(self, socket_c): ...
    def _ssl_handshake(self, connection): ...
