import netius.base.errors as errors
import netius.base.legacy as legacy
from _typeshed import Incomplete

__version__: str
__revision__: str
__date__: str

class Future:
    def __init__(self, loop: Incomplete | None = ...) -> None: ...
    def __iter__(self): ...
    def cleanup(self): ...
    def running(self): ...
    def done(self): ...
    def cancelled(self): ...
    def finished(self): ...
    def result(self): ...
    def exception(self, timeout: Incomplete | None = ...): ...
    def partial(self, value): ...
    def add_done_callback(self, function): ...
    def add_partial_callback(self, function): ...
    def add_ready_callback(self, function): ...
    def add_closed_callback(self, function): ...
    def approve(self, cleanup: bool = ...): ...
    def cancel(self, cleanup: bool = ..., force: bool = ...): ...
    def set_result(self, result, cleanup: bool = ..., force: bool = ...): ...
    def set_exception(self, exception, cleanup: bool = ..., force: bool = ...): ...
    def _done_callbacks(self, cleanup: bool = ..., delayed: bool = ...): ...
    def _partial_callbacks(self, value, delayed: bool = ...): ...
    def _wrap(self, future): ...
    def _delay(self, callable): ...
    @property
    def ready(self): ...
    @property
    def closed(self): ...

class Task(Future):
    def __init__(self, future: Incomplete | None = ...) -> None: ...

class Handle:
    def __init__(self, callable_t: Incomplete | None = ...) -> None: ...
    def cancel(self): ...

class Executor:
    def submit(self, callable, *args, **kwargs): ...

class ThreadPoolExecutor(Executor):
    def __init__(self, owner) -> None: ...
    def submit(self, callable, *args, **kwargs): ...
def coroutine(function): ...
def async_test_all(factory: Incomplete | None = ..., close: bool = ...): ...
def async_test(function): ...
def ensure_generator(value): ...
def get_asyncio(): ...
def is_coroutine(callable): ...
def is_coroutine_object(generator): ...
def is_coroutine_native(generator): ...
def is_future(future): ...
def is_neo(): ...
def is_asynclib(): ...
def is_await(): ...
def wakeup(force: bool = ...): ...
def sleep(timeout, compat: bool = ..., future: Incomplete | None = ...): ...
def wait(event, timeout: Incomplete | None = ..., future: Incomplete | None = ...): ...
def notify(event, data: Incomplete | None = ...): ...
def coroutine_return(coroutine): ...
